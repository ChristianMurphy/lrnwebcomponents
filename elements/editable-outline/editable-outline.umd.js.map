{"version":3,"file":"editable-outline.umd.js","sources":["editable-outline.umd.js"],"sourcesContent":["/**\n * Copyright 2019 The Pennsylvania State University\n * @license Apache-2.0, see License.md for full text.\n */\nimport { LitElement, html, css } from \"lit-element/lit-element.js\";\nimport { getRange } from \"@lrnwebcomponents/utils/utils.js\";\nimport \"@polymer/iron-a11y-keys/iron-a11y-keys.js\";\nimport \"@lrnwebcomponents/json-outline-schema/json-outline-schema.js\";\n/**\n * `editable-outline`\n * `a simple outline thats contenteditable in nature`\n * @demo demo/index.html\n * @customElement editable-outline\n */\nclass EditableOutline extends LitElement {\n  \n  //styles function\n  static get styles() {\n    return  [\n      css`\n:host {\n  display: block;\n  font-family: 'Noto Serif', serif;\n}\n\n:host([hidden]) {\n  display: none;\n}\n\n.button-wrapper {\n  line-height: 36px;\n  position: -webkit-sticky;\n  position: sticky;\n  top: 0px;\n  background-color: white;\n  display: block;\n  justify-content: space-evenly;\n}\n@media (max-width: 1000px) {\n  button span {\n    opacity: 0;\n    visibility: hidden;\n    position: absolute;\n    left: -9999px;\n  }\n}\nbutton {\n  height: 32px;\n  font-size: 10px;\n  margin: 0;\n  padding: 0 8px;\n}\n\nbutton span {\n  padding-left: 4px;\n  pointer-events: none;\n}\n\n#outline {\n  margin: 0;\n}\nul {\n  font-size: 16px;\n  line-height: 32px;\n  padding-left: 32px;\n  visibility: visible;\n  opacity: 1;\n  overflow: hidden;\n  height: auto;\n  transition: .2s ease-in-out all;\n}\nli {\n  font-size: 16px;\n  line-height: 32px;\n  padding: 4px;\n  transition: .2s linear all;\n}\nul:hover {\n  outline: 1px solid #EEEEEE;\n}\nli.collapsed-title {\n  background-color: #dddddd;\n}\nli.collapsed-title:after {\n  content:\"    ( Double-click to expand )\";\n}\nli:after {\n  transition: .4s ease-in-out all;\n  opacity: 0;\n  font-size: 11px;\n  visibility: hidden;\n}\nli.collapsed-title:hover:after {\n  font-style: italic;\n  opacity: 1;\n  visibility: visible;\n}\nul.collapsed-content {\n  visibility: hidden;\n  opacity: 0;\n  height: 0;\n}\nli:focus,\nli:active,\nli:hover {\n  background-color: #EEEEEE;\n  outline: 1px solid #CCCCCC;\n}\n\niron-icon {\n  pointer-events: none;\n}\n      `\n    ];\n  }\n  // render function\n  render() {\n    return html`\n\n<iron-a11y-keys keys=\"shift+tab\" @keys-pressed=\"${this._tabBackKeyPressed}\"\n  stop-keyboard-event-propagation></iron-a11y-keys>\n<iron-a11y-keys keys=\"tab\" @keys-pressed=\"${this._tabKeyPressed}\"\n  stop-keyboard-event-propagation></iron-a11y-keys>\n<iron-a11y-keys keys=\"enter\" @keys-pressed=\"${this._enterPressed}\"\n  stop-keyboard-event-propagation></iron-a11y-keys>\n<iron-a11y-keys keys=\"up\" @keys-pressed=\"${this._upPressed}\"\n  stop-keyboard-event-propagation></iron-a11y-keys>\n<iron-a11y-keys keys=\"down\" @keys-pressed=\"${this._downPressed}\"\n  stop-keyboard-event-propagation></iron-a11y-keys>\n<div class=\"button-wrapper\">\n<button @click=\"${this.buttonEvents}\" id=\"add\" title=\"Add a new node\">\n  <iron-icon icon=\"icons:add\"></iron-icon><span>Add</span>\n</button>\n<button @click=\"${this.buttonEvents}\" id=\"collapse\" title=\"Toggle active node collapsed status\">\n  <iron-icon icon=\"icons:swap-vert\"></iron-icon><span>Toggle active</span>\n</button>\n<button @click=\"${this.buttonEvents}\" id=\"collapseall\" title=\"Collapse all nodes\">\n  <iron-icon icon=\"icons:swap-vert\"></iron-icon><span>Collapse all</span>\n</button>\n<button @click=\"${this.buttonEvents}\" id=\"expandall\" title=\"Expand all nodes\">\n  <iron-icon icon=\"icons:swap-vert\"></iron-icon><span>Expand all</span>\n</button>\n<button @click=\"${this.buttonEvents}\" id=\"down\" title=\"Move active node down\">\n  <iron-icon icon=\"icons:arrow-downward\"></iron-icon><span>Move down</span>\n</button>\n<button @click=\"${this.buttonEvents}\" id=\"up\" title=\"Move active node up\">\n  <iron-icon icon=\"icons:arrow-upward\"></iron-icon><span>Move up</span>\n</button>\n<button @click=\"${this.buttonEvents}\" id=\"outdent\" title=\"Outdent active node\">\n  <iron-icon icon=\"editor:format-indent-decrease\"></iron-icon><span>Outdent</span>\n</button>\n<button @click=\"${this.buttonEvents}\" id=\"indent\" title=\"Indent active node\">\n  <iron-icon icon=\"editor:format-indent-increase\"></iron-icon><span>Indent</span>\n</button>\n<button @click=\"${this.buttonEvents}\" id=\"duplicate\" title=\"Duplicate active node tree\">\n  <iron-icon icon=\"icons:content-copy\"></iron-icon><span>Duplicate</span>\n</button>\n<button @click=\"${this.buttonEvents}\" id=\"delete\" title=\"Delete active node\">\n  <iron-icon icon=\"icons:delete\"></iron-icon><span>Delete</span>\n</button>\n</div>\n<ul id=\"outline\"></ul>`;\n  }\n\n  // properties available to the custom element for data binding\n    static get properties() {\n    return {\n  \n  ...super.properties,\n  \n  /**\n   * A items list of JSON Outline Schema Items\n   */\n  \"items\": {\n    \"type\": Array\n  },\n  /**\n   * Edit mode\n   */\n  \"editMode\": {\n    \"type\": Boolean,\n    \"attribute\": \"edit-mode\"\n  },\n  /**\n   * Outline node for keyboard key binding\n   */\n  \"__outlineNode\": {\n    \"type\": Object\n  }\n}\n;\n  }\n  constructor() {\n    super();\n    this.items = [];\n    this.editMode = false;\n    this.jos = window.JSONOutlineSchema.requestAvailability();\n    import(\"@polymer/iron-icon/iron-icon.js\");\n    import(\"@polymer/iron-icons/iron-icons.js\");\n    import(\"@polymer/iron-icons/editor-icons.js\");\n    setTimeout(() => {\n      this.addEventListener(\"dblclick\", this._collapseClickHandler.bind(this));\n    }, 0);\n  }\n  /**\n   * Store the tag name to make it easier to obtain directly.\n   * @notice function name must be here for tooling to operate correctly\n   */\n  static get tag() {\n    return \"editable-outline\";\n  }\n  /**\n   * Collapse button callback\n   */\n  _collapse(e) {\n    let node = this.getSelectionNode();\n    if (\n      node &&\n      node.tagName === \"LI\" &&\n      node.nextElementSibling &&\n      node.nextElementSibling.tagName === \"UL\"\n    ) {\n      node.classList.toggle(\"collapsed-title\");\n      node.nextElementSibling.classList.toggle(\"collapsed-content\");\n    }\n  }\n  /**\n   * Expand all items\n   */\n  _expandall(e) {\n    this.shadowRoot.querySelectorAll(\"li\").forEach(el => {\n      el.classList.remove(\"collapsed-title\");\n    });\n    this.shadowRoot.querySelectorAll(\"ul\").forEach(el => {\n      el.classList.remove(\"collapsed-content\");\n    });\n  }\n  /**\n   * Collapse all items\n   */\n  _collapseall(e) {\n    this.shadowRoot.querySelectorAll(\"li\").forEach(el => {\n      if (el.nextElementSibling && el.nextElementSibling.tagName === \"UL\") {\n        el.classList.add(\"collapsed-title\");\n        el.nextElementSibling.classList.add(\"collapsed-content\");\n      }\n    });\n  }\n  /**\n   * Click handler method needs to walk a little different then normal collapse\n   */\n  _collapseClickHandler(e) {\n    let el;\n    let i = 0;\n    let notFound = true;\n    while (notFound && e.path.length > i + 1) {\n      el = e.path[i];\n      if (\n        el.tagName === \"LI\" &&\n        el.nextElementSibling &&\n        el.nextElementSibling.tagName === \"UL\"\n      ) {\n        el.classList.toggle(\"collapsed-title\");\n        el.nextElementSibling.classList.toggle(\"collapsed-content\");\n        notFound = false;\n      }\n      i++;\n    }\n  }\n  /**\n   * delete active\n   */\n  _delete(e) {\n    let node = this.getSelectionNode();\n    if (node) {\n      const parent = node.parentNode;\n      node.remove();\n      if (parent.children.length === 0) {\n        parent.remove();\n      }\n    }\n  }\n  firstUpdated() {\n    this.__outlineNode = this.shadowRoot.querySelector(\"#outline\");\n    this.shadowRoot.querySelectorAll(\"iron-a11y-keys\").forEach(el => {\n      el.target = this.__outlineNode;\n    });\n    // required because of async rendering\n    if (!this._observer) {\n      this._observer = new MutationObserver(this._observer.bind(this));\n      this._observer.observe(this.__outlineNode, {\n        childList: true,\n        subtree: true\n      });\n    }\n  }\n  updated(changedProperties) {\n    changedProperties.forEach((oldValue, propName) => {\n      let notifiedProps = [\"editMode\", \"items\"];\n      if (notifiedProps.includes(propName)) {\n        // notify\n        let eventName = `${propName\n          .replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, \"$1-$2\")\n          .toLowerCase()}-changed`;\n        this.dispatchEvent(\n          new CustomEvent(eventName, {\n            detail: {\n              value: this[propName]\n            }\n          })\n        );\n      }\n    });\n  }\n  /**\n   * life cycle, element is afixed to the DOM\n   */\n  connectedCallback() {\n    super.connectedCallback();\n    if (this.__outlineNode) {\n      this._observer = new MutationObserver(this._observer.bind(this));\n      this._observer.observe(this.__outlineNode, {\n        childList: true,\n        subtree: true\n      });\n    }\n  }\n  /**\n   * Mutation observer callback\n   * @todo current issue if you copy and paste into the same node\n   */\n  _observer(record) {\n    for (var index in record) {\n      let info = record[index];\n      // if we've got new nodes to react to that were not imported\n      if (info.addedNodes.length > 0) {\n        // special rules for an outdent event\n        for (let i in info.addedNodes) {\n          if (info.addedNodes[i].tagName) {\n            if (info.addedNodes[i].tagName === \"LI\") {\n              if (this.__blockScrub) {\n                info.addedNodes[i].setAttribute(\"contenteditable\", \"true\");\n              } else {\n                this.jos.scrubElementJOSData(info.addedNodes[i]);\n                info.addedNodes[i].setAttribute(\"contenteditable\", \"true\");\n              }\n            }\n            // we have an unknown hest of items, scrub em all if we are in scrub mode\n            else if (info.addedNodes[i].tagName === \"UL\") {\n              if (!this.__blockScrub) {\n                this.jos.scrubElementJOSData(info.addedNodes[i]);\n              }\n            }\n          }\n        }\n      }\n    }\n    setTimeout(() => {\n      this.__blockScrub = false;\n    }, 100);\n  }\n  /**\n   * Disconnected life cycle\n   */\n  disconnectedCallback() {\n    super.disconnectedCallback();\n  }\n\n  /**\n   * Button events internally\n   */\n  buttonEvents(e) {\n    switch (e.target.id) {\n      case \"add\":\n        this._add(e);\n        break;\n      case \"collapse\":\n        this._collapse(e);\n        break;\n      case \"collapseall\":\n        this._collapseall(e);\n        break;\n      case \"expandall\":\n        this._expandall(e);\n        break;\n      case \"indent\":\n        this._indent();\n        break;\n      case \"outdent\":\n        this._outdent();\n        break;\n      case \"up\":\n        this._move(\"up\");\n        break;\n      case \"down\":\n        this._move(\"down\");\n        break;\n      case \"duplicate\":\n        this._duplicate();\n        break;\n      case \"delete\":\n        this._delete();\n        break;\n    }\n  }\n  /**\n   * Duplicate whatever has selection\n   */\n  _duplicate() {\n    // get active item from where cursor is\n    try {\n      this.__blockScrub = false;\n      let activeItem = this.getSelectionNode();\n      if (activeItem && activeItem.tagName === \"LI\") {\n        // clone the item's hierarchy as well\n        if (\n          activeItem.nextElementSibling !== null &&\n          activeItem.nextElementSibling.tagName === \"UL\"\n        ) {\n          // copy the UL and all children and insert it after the UL it's duplicating\n          const clone2 = activeItem.nextElementSibling.cloneNode(true);\n          activeItem.parentNode.insertBefore(\n            clone2,\n            activeItem.nextElementSibling.nextElementSibling\n          );\n          // clone the LI, placing it before the UL we just made\n          const clone = activeItem.cloneNode(true);\n          activeItem.parentNode.insertBefore(\n            clone,\n            activeItem.nextElementSibling.nextElementSibling\n          );\n        } else {\n          const clone = activeItem.cloneNode(true);\n          // insert the clone AFTER the current selection\n          activeItem.parentNode.insertBefore(\n            clone,\n            activeItem.nextElementSibling\n          );\n        }\n      }\n    } catch (e) {\n      console.log(e);\n    }\n  }\n  /**\n   * Move whatever has selection up or down\n   */\n  _move(direction) {\n    // get active item from where cursor is\n    try {\n      let activeItem = this.getSelectionNode();\n      let test = activeItem;\n      let valid = false;\n      if (activeItem == null) {\n        return false;\n      }\n      // ensure this operation is executed in scope\n      while (!valid && test.parentNode) {\n        if (test.id === \"outline\") {\n          valid = true;\n        }\n        test = test.parentNode;\n      }\n      // ensure from all that, we have something\n      if (valid && activeItem && activeItem.tagName === \"LI\") {\n        // move the things above us, below us\n        if (direction === \"up\") {\n          // ensure there's something above us\n          if (activeItem.previousElementSibling !== null) {\n            // see if we are moving us, or us and the hierarchy\n            if (\n              activeItem.nextElementSibling &&\n              activeItem.nextElementSibling.tagName === \"UL\"\n            ) {\n              // see if the thing we have to move above has it's own structure\n              if (activeItem.previousElementSibling.tagName === \"UL\") {\n                // ensure we don't lose our metadata\n                this.__blockScrub = true;\n                // insert the element currently above us, just before 2 places back; so behind our UL\n                activeItem.parentNode.insertBefore(\n                  activeItem.previousElementSibling,\n                  activeItem.nextElementSibling.nextElementSibling\n                );\n              }\n              this.__blockScrub = true;\n              // now insert the LI above us, 2 places back so it is in front of the UL\n              activeItem.parentNode.insertBefore(\n                activeItem.previousElementSibling,\n                activeItem.nextElementSibling.nextElementSibling\n              );\n              activeItem.focus();\n            } else {\n              // easier use case, we are moving ourselves only but above us is a UL\n              if (activeItem.previousElementSibling.tagName === \"UL\") {\n                this.__blockScrub = true;\n                // move the UL after us\n                activeItem.parentNode.insertBefore(\n                  activeItem.previousElementSibling,\n                  activeItem.nextElementSibling\n                );\n              }\n              this.__blockScrub = true;\n              // now move the LI after us\n              activeItem.parentNode.insertBefore(\n                activeItem.previousElementSibling,\n                activeItem.nextElementSibling\n              );\n              activeItem.focus();\n            }\n          }\n        } else if (direction === \"down\") {\n          // if nothing after us, we can't move\n          if (activeItem.nextElementSibling !== null) {\n            // account for having to hop over children\n            if (\n              activeItem.nextElementSibling &&\n              activeItem.nextElementSibling.tagName === \"UL\" &&\n              activeItem.nextElementSibling.nextElementSibling !== null\n            ) {\n              // an outline is just below us\n              if (\n                activeItem.nextElementSibling.nextElementSibling.tagName ===\n                  \"LI\" &&\n                activeItem.nextElementSibling.nextElementSibling\n                  .nextElementSibling !== null &&\n                activeItem.nextElementSibling.nextElementSibling\n                  .nextElementSibling.tagName === \"UL\"\n              ) {\n                this.__blockScrub = true;\n                // move the thing 2 down to just before us; so the UL\n                activeItem.parentNode.insertBefore(\n                  activeItem.nextElementSibling.nextElementSibling,\n                  activeItem\n                );\n              }\n              this.__blockScrub = true;\n              // now move the LI that is 2 below us just above us\n              activeItem.parentNode.insertBefore(\n                activeItem.nextElementSibling.nextElementSibling,\n                activeItem\n              );\n              activeItem.focus();\n            } else if (activeItem.nextElementSibling.tagName === \"LI\") {\n              // just moving 1 tag, see if we need to move 2 things about us or 1\n              if (\n                activeItem.nextElementSibling.nextElementSibling !== null &&\n                activeItem.nextElementSibling.nextElementSibling.tagName ===\n                  \"UL\"\n              ) {\n                this.__blockScrub = true;\n                activeItem.parentNode.insertBefore(\n                  activeItem.nextElementSibling,\n                  activeItem\n                );\n              }\n              this.__blockScrub = true;\n              // work on the LI\n              activeItem.parentNode.insertBefore(\n                activeItem.nextElementSibling,\n                activeItem\n              );\n              activeItem.focus();\n            }\n          }\n        }\n      }\n    } catch (e) {\n      console.log(e);\n    }\n  }\n  /**\n   * Take the current manifest and import it into an HTML outline\n   */\n  importJsonOutlineSchemaItems() {\n    this.__blockScrub = true;\n    // wipe out the outline\n    while (this.__outlineNode.firstChild !== null) {\n      this.__outlineNode.removeChild(this.__outlineNode.firstChild);\n    }\n    if (this.items.length === 0) {\n      // get from JOS items if we have none currently\n      this.items = [...this.jos.items];\n    }\n    let outline = this.jos.itemsToNodes(this.items);\n    // rebuild the outline w/ children we just found\n    while (outline.firstChild !== null) {\n      this.__blockScrub = true;\n      this.__outlineNode.appendChild(outline.firstChild);\n    }\n    this.shadowRoot.querySelectorAll(\"li\").forEach(el => {\n      el.setAttribute(\"contenteditable\", \"true\");\n    });\n    return outline;\n  }\n  /**\n   * Take what's currently in the area and get JSON Outline Schema; optionally save\n   */\n  exportJsonOutlineSchemaItems(save = false) {\n    return this.jos.nodesToItems(this.__outlineNode, save);\n  }\n  _upPressed(e) {\n    let node = this.getSelectionNode();\n    if (node && node.previousSibling && node.previousSibling.tagName === \"LI\") {\n      node.previousSibling.focus();\n    } else if (\n      node &&\n      node.previousSibling &&\n      node.previousSibling.tagName === \"UL\" &&\n      node.previousSibling.firstChild &&\n      node.previousSibling.firstChild.tagName === \"LI\"\n    ) {\n      node.previousSibling.firstChild.focus();\n    } else if (\n      node &&\n      node.previousSibling == null &&\n      node.parentNode.tagName === \"UL\" &&\n      node.parentNode.previousSibling &&\n      node.parentNode.previousSibling.tagName === \"LI\"\n    ) {\n      node.parentNode.previousSibling.focus();\n    }\n  }\n  _downPressed(e) {\n    let node = this.getSelectionNode();\n    if (node && node.nextSibling && node.nextSibling.tagName === \"LI\") {\n      node.nextSibling.focus();\n    } else if (\n      node &&\n      node.nextSibling &&\n      node.nextSibling.tagName === \"UL\" &&\n      node.nextSibling.firstChild &&\n      node.nextSibling.firstChild.tagName === \"LI\"\n    ) {\n      node.nextSibling.firstChild.focus();\n    } else if (\n      node &&\n      node.nextSibling == null &&\n      node.parentNode.tagName === \"UL\" &&\n      node.parentNode.nextSibling &&\n      node.parentNode.nextSibling.tagName === \"LI\"\n    ) {\n      node.parentNode.nextSibling.focus();\n    }\n  }\n  /**\n   * Find the next thing to tab forward to.\n   */\n  _tabKeyPressed(e) {\n    e.preventDefault();\n    e.stopPropagation();\n    e.stopImmediatePropagation();\n    if (e.detail.keyboardEvent) {\n      e.detail.keyboardEvent.preventDefault();\n      e.detail.keyboardEvent.stopPropagation();\n      e.detail.keyboardEvent.stopImmediatePropagation();\n    }\n    try {\n      this._indent();\n    } catch (e) {}\n  }\n  /**\n   * Move back through things when tab back pressed\n   */\n  _tabBackKeyPressed(e) {\n    e.preventDefault();\n    e.stopPropagation();\n    e.stopImmediatePropagation();\n    if (e.detail.keyboardEvent) {\n      e.detail.keyboardEvent.preventDefault();\n      e.detail.keyboardEvent.stopPropagation();\n      e.detail.keyboardEvent.stopImmediatePropagation();\n    }\n    try {\n      this._outdent();\n    } catch (e) {}\n  }\n  _enterPressed(e) {\n    e.preventDefault();\n    e.stopPropagation();\n    e.stopImmediatePropagation();\n    // prevent the contenteditable stuff\n    if (e.detail.keyboardEvent) {\n      e.detail.keyboardEvent.preventDefault();\n      e.detail.keyboardEvent.stopPropagation();\n      e.detail.keyboardEvent.stopImmediatePropagation();\n    }\n    this._add();\n  }\n  _add() {\n    let li = document.createElement(\"li\");\n    li.setAttribute(\"contenteditable\", \"true\");\n    let node = this.getSelectionNode();\n    if (\n      this.__outlineNode.querySelector(\"li\") == null ||\n      !node ||\n      (node.tagName && (node.tagName != \"UL\" && node.tagName != \"LI\"))\n    ) {\n      this.__outlineNode.appendChild(li);\n    } else {\n      if ((node.tagName == null || node.tagName != \"LI\") && node.parentNode) {\n        node = node.parentNode;\n      }\n      if (node.nextSibling == null) {\n        node.parentNode.appendChild(li);\n      } else {\n        node.parentNode.insertBefore(li, node.nextSibling);\n      }\n      try {\n        li.focus();\n      } catch (e) {\n        // prevent issue on polyfill browsers potentially\n      }\n    }\n  }\n  _outdent() {\n    this.__blockScrub = true;\n    try {\n      let node = this.getSelectionNode();\n      if (node == null) {\n        return false;\n      }\n      // need to hold this in case it's empty at the end\n      const parent = node.parentNode;\n      if (\n        node.parentNode &&\n        node.parentNode != this.__outlineNode &&\n        node.parentNode.nextSibling != null\n      ) {\n        node.parentNode.parentNode.insertBefore(\n          node,\n          node.parentNode.nextSibling\n        );\n        if (parent.children.length == 0) {\n          parent.remove();\n        }\n      } else if (\n        node.parentNode &&\n        node.parentNode != this.__outlineNode &&\n        node.parentNode.nextSibling == null\n      ) {\n        node.parentNode.parentNode.appendChild(node);\n        if (parent.children.length == 0) {\n          parent.remove();\n        }\n      }\n      node.focus();\n    } catch (e) {\n      console.warn(e);\n    }\n  }\n  _indent() {\n    this.__blockScrub = true;\n    try {\n      let node = this.getSelectionNode();\n      if (node == null) {\n        return false;\n      }\n      // see if the previous tag is a LI, if so we can indent\n      if (\n        node.previousSibling != null &&\n        node.previousSibling.tagName === \"LI\"\n      ) {\n        let ul;\n        if (node.nextSibling && node.nextSibling.tagName === \"UL\") {\n          ul = node.nextSibling;\n        } else {\n          ul = document.createElement(\"ul\");\n          node.parentNode.insertBefore(ul, node);\n        }\n        // append a new list inside the child before the active node position\n        // now append into that list the node that was active\n        ul.appendChild(node);\n        node.focus();\n      } else if (\n        node.previousSibling != null &&\n        node.previousSibling.tagName === \"UL\"\n      ) {\n        node.previousSibling.appendChild(node);\n        node.focus();\n      }\n    } catch (e) {\n      console.warn(e);\n    }\n  }\n  getSelectionNode() {\n    let node = this.getDeepSelection().anchorNode;\n    if (\n      node &&\n      (node.tagName == null || node.tagName != \"LI\") &&\n      node.parentNode\n    ) {\n      node = node.parentNode;\n    }\n    return node;\n  }\n  /**\n   * Selection normalizer\n   */\n  getDeepSelection() {\n    // try and obtain the selection from the nearest shadow\n    // which would give us the selection object when running native ShadowDOM\n    // with fallback support for the entire window which would imply Shady\n    // native API\n    if (this.shadowRoot.getSelection) {\n      return this.shadowRoot.getSelection();\n    }\n    // ponyfill from google\n    else if (getRange(this.__outlineNode.parentNode)) {\n      return getRange(this.__outlineNode.parentNode);\n    }\n    // missed on both, hope the normal one will work\n    return window.getSelection();\n  }\n  /**\n   * Get a normalized range based on current selection\n   */\n  getDeepRange() {\n    let sel = this.getDeepSelection();\n    if (sel.getRangeAt && sel.rangeCount) {\n      return sel.getRangeAt(0);\n    } else if (sel) {\n      return sel;\n    } else false;\n  }\n}\nwindow.customElements.define(EditableOutline.tag, EditableOutline);\nexport { EditableOutline };\n"],"names":["EditableOutline","items","editMode","jos","window","JSONOutlineSchema","requestAvailability","setTimeout","addEventListener","_this","_collapseClickHandler","bind","LitElement","html","this","_tabBackKeyPressed","_tabKeyPressed","_enterPressed","_upPressed","_downPressed","buttonEvents","css","Array","Boolean","Object","e","node","getSelectionNode","tagName","nextElementSibling","classList","toggle","shadowRoot","querySelectorAll","forEach","el","remove","add","i","notFound","path","length","parent","parentNode","children","__outlineNode","querySelector","target","_this2","_observer","MutationObserver","observe","childList","subtree","changedProperties","oldValue","propName","includes","eventName","replace","toLowerCase","_this3","dispatchEvent","CustomEvent","detail","value","record","index","info","addedNodes","__blockScrub","setAttribute","scrubElementJOSData","_this4","id","_add","_collapse","_collapseall","_expandall","_indent","_outdent","_move","_duplicate","_delete","activeItem","clone2","cloneNode","insertBefore","clone","console","log","direction","test","valid","previousElementSibling","focus","firstChild","removeChild","outline","itemsToNodes","appendChild","save","nodesToItems","previousSibling","nextSibling","preventDefault","stopPropagation","stopImmediatePropagation","keyboardEvent","li","document","createElement","warn","ul","getDeepSelection","anchorNode","getSelection","getRange","sel","getRangeAt","rangeCount","customElements","define","tag"],"mappings":"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"}