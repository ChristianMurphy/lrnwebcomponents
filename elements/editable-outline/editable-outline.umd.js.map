{"version":3,"file":"editable-outline.umd.js","sources":["editable-outline.umd.js"],"sourcesContent":["/**\n * Copyright 2019 The Pennsylvania State University\n * @license Apache-2.0, see License.md for full text.\n */\nimport { LitElement, html, css } from \"lit-element/lit-element.js\";\nimport { getRange } from \"@lrnwebcomponents/utils/utils.js\";\nimport \"@polymer/iron-a11y-keys/iron-a11y-keys.js\";\nimport \"@lrnwebcomponents/json-outline-schema/json-outline-schema.js\";\n/**\n * `editable-outline`\n * `a simple outline thats contenteditable in nature`\n * @demo demo/index.html\n * @customElement editable-outline\n */\nclass EditableOutline extends LitElement {\n  \n  //styles function\n  static get styles() {\n    return  [\n      \n      css`\n:host {\n  display: block;\n  font-family: 'Noto Serif', serif;\n}\n\n:host([hidden]) {\n  display: none;\n}\n\n.button-wrapper {\n  line-height: 36px;\n  position: -webkit-sticky;\n  position: sticky;\n  top: 0px;\n  background-color: white;\n  display: block;\n  justify-content: space-evenly;\n}\n@media (max-width: 1000px) {\n  button span {\n    opacity: 0;\n    visibility: hidden;\n    position: absolute;\n    left: -9999px;\n  }\n}\nbutton {\n  height: 32px;\n  font-size: 10px;\n  margin: 0;\n  padding: 0 8px;\n}\n\nbutton span {\n  padding-left: 4px;\n  pointer-events: none;\n}\n\n#outline {\n  margin: 0;\n}\nul {\n  font-size: 16px;\n  line-height: 32px;\n  padding-left: 32px;\n  visibility: visible;\n  opacity: 1;\n  overflow: hidden;\n  height: auto;\n  transition: .2s ease-in-out all;\n}\nli {\n  font-size: 16px;\n  line-height: 32px;\n  padding: 4px;\n  transition: .2s linear all;\n}\nul:hover {\n  outline: 1px solid #EEEEEE;\n}\nli.collapsed-title {\n  background-color: #dddddd;\n}\nli.collapsed-title:after {\n  content:\"    ( Double-click to expand )\";\n}\nli:after {\n  transition: .4s ease-in-out all;\n  opacity: 0;\n  font-size: 11px;\n  visibility: hidden;\n}\nli.collapsed-title:hover:after {\n  font-style: italic;\n  opacity: 1;\n  visibility: visible;\n}\nul.collapsed-content {\n  visibility: hidden;\n  opacity: 0;\n  height: 0;\n}\nli:focus,\nli:active,\nli:hover {\n  background-color: #EEEEEE;\n  outline: 1px solid #CCCCCC;\n}\n\niron-icon {\n  pointer-events: none;\n}\n      `\n    ];\n  }\n  // render function\n  render() {\n    return html`\n\n<iron-a11y-keys keys=\"enter\" @keys-pressed=\"${this._enterPressed}\"\n  stop-keyboard-event-propagation></iron-a11y-keys>\n<iron-a11y-keys keys=\"up\" @keys-pressed=\"${this._upPressed}\"\n  stop-keyboard-event-propagation></iron-a11y-keys>\n<iron-a11y-keys keys=\"down\" @keys-pressed=\"${this._downPressed}\"\n  stop-keyboard-event-propagation></iron-a11y-keys>\n<div class=\"button-wrapper\">\n<button @click=\"${this.buttonEvents}\" id=\"add\" title=\"Add a new node\">\n  <iron-icon icon=\"icons:add\"></iron-icon><span>Add</span>\n</button>\n<button @click=\"${this.buttonEvents}\" id=\"collapse\" title=\"Toggle active node collapsed status\">\n  <iron-icon icon=\"icons:swap-vert\"></iron-icon><span>Toggle active</span>\n</button>\n<button @click=\"${this.buttonEvents}\" id=\"collapseall\" title=\"Collapse all nodes\">\n  <iron-icon icon=\"icons:swap-vert\"></iron-icon><span>Collapse all</span>\n</button>\n<button @click=\"${this.buttonEvents}\" id=\"expandall\" title=\"Expand all nodes\">\n  <iron-icon icon=\"icons:swap-vert\"></iron-icon><span>Expand all</span>\n</button>\n<button @click=\"${this.buttonEvents}\" id=\"down\" title=\"Move active node down\">\n  <iron-icon icon=\"icons:arrow-downward\"></iron-icon><span>Move down</span>\n</button>\n<button @click=\"${this.buttonEvents}\" id=\"up\" title=\"Move active node up\">\n  <iron-icon icon=\"icons:arrow-upward\"></iron-icon><span>Move up</span>\n</button>\n<button @click=\"${this.buttonEvents}\" id=\"outdent\" title=\"Outdent active node\">\n  <iron-icon icon=\"editor:format-indent-decrease\"></iron-icon><span>Outdent</span>\n</button>\n<button @click=\"${this.buttonEvents}\" id=\"indent\" title=\"Indent active node\">\n  <iron-icon icon=\"editor:format-indent-increase\"></iron-icon><span>Indent</span>\n</button>\n<button @click=\"${this.buttonEvents}\" id=\"duplicate\" title=\"Duplicate active node tree\">\n  <iron-icon icon=\"icons:content-copy\"></iron-icon><span>Duplicate</span>\n</button>\n<button @click=\"${this.buttonEvents}\" id=\"delete\" title=\"Delete active node\">\n  <iron-icon icon=\"icons:delete\"></iron-icon><span>Delete</span>\n</button>\n</div>\n<ul id=\"outline\"></ul>`;\n  }\n\n  // properties available to the custom element for data binding\n    static get properties() {\n    return {\n  \n  ...super.properties,\n  \n  /**\n   * A items list of JSON Outline Schema Items\n   */\n  \"items\": {\n    \"type\": Array\n  },\n  /**\n   * Edit mode\n   */\n  \"editMode\": {\n    \"type\": Boolean,\n    \"attribute\": \"edit-mode\"\n  },\n  /**\n   * Outline node for keyboard key binding\n   */\n  \"__outlineNode\": {\n    \"type\": Object\n  }\n}\n;\n  }\n  constructor() {\n    super();\n    this.items = [];\n    this.editMode = false;\n    this.jos = window.JSONOutlineSchema.requestAvailability();\n    import(\"@polymer/iron-icon/iron-icon.js\");\n    import(\"@polymer/iron-icons/iron-icons.js\");\n    import(\"@polymer/iron-icons/editor-icons.js\");\n    setTimeout(() => {\n      this.addEventListener(\"dblclick\", this._collapseClickHandler.bind(this));\n    }, 0);\n  }\n  /**\n   * Store the tag name to make it easier to obtain directly.\n   * @notice function name must be here for tooling to operate correctly\n   */\n  static get tag() {\n    return \"editable-outline\";\n  }\n  /**\n   * Collapse button callback\n   */\n  _collapse(e) {\n    let node = this.getSelectionNode();\n    if (\n      node &&\n      node.tagName === \"LI\" &&\n      node.nextElementSibling &&\n      node.nextElementSibling.tagName === \"UL\"\n    ) {\n      node.classList.toggle(\"collapsed-title\");\n      node.nextElementSibling.classList.toggle(\"collapsed-content\");\n    }\n  }\n  /**\n   * Expand all items\n   */\n  _expandall(e) {\n    this.shadowRoot.querySelectorAll(\"li\").forEach(el => {\n      el.classList.remove(\"collapsed-title\");\n    });\n    this.shadowRoot.querySelectorAll(\"ul\").forEach(el => {\n      el.classList.remove(\"collapsed-content\");\n    });\n  }\n  /**\n   * Collapse all items\n   */\n  _collapseall(e) {\n    this.shadowRoot.querySelectorAll(\"li\").forEach(el => {\n      if (el.nextElementSibling && el.nextElementSibling.tagName === \"UL\") {\n        el.classList.add(\"collapsed-title\");\n        el.nextElementSibling.classList.add(\"collapsed-content\");\n      }\n    });\n  }\n  _onKeyDown(e) {\n    if (this.editMode) {\n      switch (e.key) {\n        case \"Tab\":\n          if (e.shiftKey) {\n            this._tabBackKeyPressed(e);\n          } else {\n            this._tabKeyPressed(e);\n          }\n          break;\n      }\n    }\n  }\n  /**\n   * Click handler method needs to walk a little different then normal collapse\n   */\n  _collapseClickHandler(e) {\n    let el;\n    let i = 0;\n    let notFound = true;\n    while (notFound && e.path.length > i + 1) {\n      el = e.path[i];\n      if (\n        el.tagName === \"LI\" &&\n        el.nextElementSibling &&\n        el.nextElementSibling.tagName === \"UL\"\n      ) {\n        el.classList.toggle(\"collapsed-title\");\n        el.nextElementSibling.classList.toggle(\"collapsed-content\");\n        notFound = false;\n      }\n      i++;\n    }\n  }\n  /**\n   * delete active\n   */\n  _delete(e) {\n    let node = this.getSelectionNode();\n    if (node && node.tagName === \"LI\") {\n      const parent = node.parentNode;\n      node.remove();\n      if (parent.children.length === 0) {\n        parent.remove();\n      }\n    }\n  }\n  firstUpdated() {\n    this.__outlineNode = this.shadowRoot.querySelector(\"#outline\");\n    this.shadowRoot.querySelectorAll(\"iron-a11y-keys\").forEach(el => {\n      el.target = this.__outlineNode;\n    });\n    this.__outlineNode.addEventListener(\"keydown\", this._onKeyDown.bind(this));\n    this._observer = new MutationObserver(this._observeRecord.bind(this));\n    this._observer.observe(this.__outlineNode, {\n      childList: true,\n      subtree: true\n    });\n  }\n  updated(changedProperties) {\n    changedProperties.forEach((oldValue, propName) => {\n      let notifiedProps = [\"editMode\", \"items\"];\n      if (notifiedProps.includes(propName)) {\n        // notify\n        let eventName = `${propName\n          .replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, \"$1-$2\")\n          .toLowerCase()}-changed`;\n        this.dispatchEvent(\n          new CustomEvent(eventName, {\n            detail: {\n              value: this[propName]\n            }\n          })\n        );\n      }\n    });\n  }\n  /**\n   * Mutation observer callback\n   * @todo current issue if you copy and paste into the same node\n   */\n  _observeRecord(record) {\n    for (var index in record) {\n      let info = record[index];\n      // if we've got new nodes to react to that were not imported\n      if (info.addedNodes.length > 0) {\n        // special rules for an outdent event\n        for (let i in info.addedNodes) {\n          if (info.addedNodes[i].tagName) {\n            if (info.addedNodes[i].tagName === \"LI\") {\n              if (this.__blockScrub) {\n                info.addedNodes[i].setAttribute(\"contenteditable\", \"true\");\n              } else {\n                this.jos.scrubElementJOSData(info.addedNodes[i]);\n                info.addedNodes[i].setAttribute(\"contenteditable\", \"true\");\n              }\n            }\n            // we have an unknown hest of items, scrub em all if we are in scrub mode\n            else if (info.addedNodes[i].tagName === \"UL\") {\n              if (!this.__blockScrub) {\n                this.jos.scrubElementJOSData(info.addedNodes[i]);\n              }\n            }\n          }\n        }\n      }\n    }\n    setTimeout(() => {\n      this.__blockScrub = false;\n    }, 100);\n  }\n  /**\n   * Disconnected life cycle\n   */\n  disconnectedCallback() {\n    this.__outlineNode.removeEventListener(\n      \"keydown\",\n      this._onKeyDown.bind(this)\n    );\n    this._observer.disconnect();\n    super.disconnectedCallback();\n  }\n\n  /**\n   * Button events internally\n   */\n  buttonEvents(e) {\n    switch (e.target.id) {\n      case \"add\":\n        this._add(e);\n        break;\n      case \"collapse\":\n        this._collapse(e);\n        break;\n      case \"collapseall\":\n        this._collapseall(e);\n        break;\n      case \"expandall\":\n        this._expandall(e);\n        break;\n      case \"indent\":\n        this._indent();\n        break;\n      case \"outdent\":\n        this._outdent();\n        break;\n      case \"up\":\n        this._move(\"up\");\n        break;\n      case \"down\":\n        this._move(\"down\");\n        break;\n      case \"duplicate\":\n        this._duplicate();\n        break;\n      case \"delete\":\n        this._delete();\n        break;\n    }\n  }\n  /**\n   * Duplicate whatever has selection\n   */\n  _duplicate() {\n    // get active item from where cursor is\n    try {\n      this.__blockScrub = false;\n      let activeItem = this.getSelectionNode();\n      if (activeItem && activeItem.tagName === \"LI\") {\n        // clone the item's hierarchy as well\n        if (\n          activeItem.nextElementSibling !== null &&\n          activeItem.nextElementSibling.tagName === \"UL\"\n        ) {\n          // copy the UL and all children and insert it after the UL it's duplicating\n          const clone2 = activeItem.nextElementSibling.cloneNode(true);\n          activeItem.parentNode.insertBefore(\n            clone2,\n            activeItem.nextElementSibling.nextElementSibling\n          );\n          // clone the LI, placing it before the UL we just made\n          const clone = activeItem.cloneNode(true);\n          activeItem.parentNode.insertBefore(\n            clone,\n            activeItem.nextElementSibling.nextElementSibling\n          );\n        } else {\n          const clone = activeItem.cloneNode(true);\n          // insert the clone AFTER the current selection\n          activeItem.parentNode.insertBefore(\n            clone,\n            activeItem.nextElementSibling\n          );\n        }\n      }\n    } catch (e) {\n      console.log(e);\n    }\n  }\n  /**\n   * Move whatever has selection up or down\n   */\n  _move(direction) {\n    // get active item from where cursor is\n    try {\n      let activeItem = this.getSelectionNode();\n      let test = activeItem;\n      let valid = false;\n      if (activeItem == null) {\n        return false;\n      }\n      // ensure this operation is executed in scope\n      while (!valid && test.parentNode) {\n        if (test.id === \"outline\") {\n          valid = true;\n        }\n        test = test.parentNode;\n      }\n      // ensure from all that, we have something\n      if (valid && activeItem && activeItem.tagName === \"LI\") {\n        // move the things above us, below us\n        if (direction === \"up\") {\n          // ensure there's something above us\n          if (activeItem.previousElementSibling !== null) {\n            // see if we are moving us, or us and the hierarchy\n            if (\n              activeItem.nextElementSibling &&\n              activeItem.nextElementSibling.tagName === \"UL\"\n            ) {\n              // see if the thing we have to move above has it's own structure\n              if (activeItem.previousElementSibling.tagName === \"UL\") {\n                // ensure we don't lose our metadata\n                this.__blockScrub = true;\n                // insert the element currently above us, just before 2 places back; so behind our UL\n                activeItem.parentNode.insertBefore(\n                  activeItem.previousElementSibling,\n                  activeItem.nextElementSibling.nextElementSibling\n                );\n              }\n              this.__blockScrub = true;\n              // now insert the LI above us, 2 places back so it is in front of the UL\n              activeItem.parentNode.insertBefore(\n                activeItem.previousElementSibling,\n                activeItem.nextElementSibling.nextElementSibling\n              );\n              activeItem.focus();\n            } else {\n              // easier use case, we are moving ourselves only but above us is a UL\n              if (activeItem.previousElementSibling.tagName === \"UL\") {\n                this.__blockScrub = true;\n                // move the UL after us\n                activeItem.parentNode.insertBefore(\n                  activeItem.previousElementSibling,\n                  activeItem.nextElementSibling\n                );\n              }\n              this.__blockScrub = true;\n              // now move the LI after us\n              activeItem.parentNode.insertBefore(\n                activeItem.previousElementSibling,\n                activeItem.nextElementSibling\n              );\n              activeItem.focus();\n            }\n          }\n        } else if (direction === \"down\") {\n          // if nothing after us, we can't move\n          if (activeItem.nextElementSibling !== null) {\n            // account for having to hop over children\n            if (\n              activeItem.nextElementSibling &&\n              activeItem.nextElementSibling.tagName === \"UL\" &&\n              activeItem.nextElementSibling.nextElementSibling !== null\n            ) {\n              // an outline is just below us\n              if (\n                activeItem.nextElementSibling.nextElementSibling.tagName ===\n                  \"LI\" &&\n                activeItem.nextElementSibling.nextElementSibling\n                  .nextElementSibling !== null &&\n                activeItem.nextElementSibling.nextElementSibling\n                  .nextElementSibling.tagName === \"UL\"\n              ) {\n                this.__blockScrub = true;\n                // move the thing 2 down to just before us; so the UL\n                activeItem.parentNode.insertBefore(\n                  activeItem.nextElementSibling.nextElementSibling,\n                  activeItem\n                );\n              }\n              this.__blockScrub = true;\n              // now move the LI that is 2 below us just above us\n              activeItem.parentNode.insertBefore(\n                activeItem.nextElementSibling.nextElementSibling,\n                activeItem\n              );\n              activeItem.focus();\n            } else if (activeItem.nextElementSibling.tagName === \"LI\") {\n              // just moving 1 tag, see if we need to move 2 things about us or 1\n              if (\n                activeItem.nextElementSibling.nextElementSibling !== null &&\n                activeItem.nextElementSibling.nextElementSibling.tagName ===\n                  \"UL\"\n              ) {\n                this.__blockScrub = true;\n                activeItem.parentNode.insertBefore(\n                  activeItem.nextElementSibling,\n                  activeItem\n                );\n              }\n              this.__blockScrub = true;\n              // work on the LI\n              activeItem.parentNode.insertBefore(\n                activeItem.nextElementSibling,\n                activeItem\n              );\n              activeItem.focus();\n            }\n          }\n        }\n      }\n    } catch (e) {\n      console.log(e);\n    }\n  }\n  /**\n   * Take the current manifest and import it into an HTML outline\n   */\n  importJsonOutlineSchemaItems() {\n    this.__blockScrub = true;\n    setTimeout(() => {\n      // wipe out the outline\n      while (this.__outlineNode.firstChild) {\n        this.__outlineNode.removeChild(this.__outlineNode.firstChild);\n      }\n      if (this.items.length === 0) {\n        // get from JOS items if we have none currently\n        this.items = [...this.jos.items];\n      }\n      let outline = this.jos.itemsToNodes(this.items);\n      // rebuild the outline w/ children we just found\n      while (outline.firstChild) {\n        this.__blockScrub = true;\n        this.__outlineNode.appendChild(outline.firstChild);\n      }\n      this.shadowRoot.querySelectorAll(\"li\").forEach(el => {\n        el.setAttribute(\"contenteditable\", \"true\");\n      });\n    }, 0);\n    return outline;\n  }\n  /**\n   * Take what's currently in the area and get JSON Outline Schema; optionally save\n   */\n  exportJsonOutlineSchemaItems(save = false) {\n    return this.jos.nodesToItems(this.__outlineNode, save);\n  }\n  _upPressed(e) {\n    let node = this.getSelectionNode();\n    if (node && node.previousSibling && node.previousSibling.tagName === \"LI\") {\n      node.previousSibling.focus();\n    } else if (\n      node &&\n      node.previousSibling &&\n      node.previousSibling.tagName === \"UL\" &&\n      node.previousSibling.firstChild &&\n      node.previousSibling.firstChild.tagName === \"LI\"\n    ) {\n      node.previousSibling.firstChild.focus();\n    } else if (\n      node &&\n      node.previousSibling == null &&\n      node.parentNode.tagName === \"UL\" &&\n      node.parentNode.previousSibling &&\n      node.parentNode.previousSibling.tagName === \"LI\"\n    ) {\n      node.parentNode.previousSibling.focus();\n    }\n  }\n  _downPressed(e) {\n    let node = this.getSelectionNode();\n    if (node && node.nextSibling && node.nextSibling.tagName === \"LI\") {\n      node.nextSibling.focus();\n    } else if (\n      node &&\n      node.nextSibling &&\n      node.nextSibling.tagName === \"UL\" &&\n      node.nextSibling.firstChild &&\n      node.nextSibling.firstChild.tagName === \"LI\"\n    ) {\n      node.nextSibling.firstChild.focus();\n    } else if (\n      node &&\n      node.nextSibling == null &&\n      node.parentNode.tagName === \"UL\" &&\n      node.parentNode.nextSibling &&\n      node.parentNode.nextSibling.tagName === \"LI\"\n    ) {\n      node.parentNode.nextSibling.focus();\n    }\n  }\n  /**\n   * Find the next thing to tab forward to.\n   */\n  _tabKeyPressed(e) {\n    e.preventDefault();\n    e.stopPropagation();\n    e.stopImmediatePropagation();\n    if (e.detail.keyboardEvent) {\n      e.detail.keyboardEvent.preventDefault();\n      e.detail.keyboardEvent.stopPropagation();\n      e.detail.keyboardEvent.stopImmediatePropagation();\n    }\n    try {\n      this._indent();\n    } catch (e) {}\n  }\n  /**\n   * Move back through things when tab back pressed\n   */\n  _tabBackKeyPressed(e) {\n    e.preventDefault();\n    e.stopPropagation();\n    e.stopImmediatePropagation();\n    if (e.detail.keyboardEvent) {\n      e.detail.keyboardEvent.preventDefault();\n      e.detail.keyboardEvent.stopPropagation();\n      e.detail.keyboardEvent.stopImmediatePropagation();\n    }\n    try {\n      this._outdent();\n    } catch (e) {}\n  }\n  _enterPressed(e) {\n    e.preventDefault();\n    e.stopPropagation();\n    e.stopImmediatePropagation();\n    // prevent the contenteditable stuff\n    if (e.detail.keyboardEvent) {\n      e.detail.keyboardEvent.preventDefault();\n      e.detail.keyboardEvent.stopPropagation();\n      e.detail.keyboardEvent.stopImmediatePropagation();\n    }\n    this._add();\n  }\n  _add() {\n    let li = document.createElement(\"li\");\n    li.setAttribute(\"contenteditable\", \"true\");\n    let node = this.getSelectionNode();\n    if (\n      this.__outlineNode.querySelector(\"li\") == null ||\n      !node ||\n      (node.tagName && (node.tagName != \"UL\" && node.tagName != \"LI\"))\n    ) {\n      this.__outlineNode.appendChild(li);\n    } else {\n      if ((node.tagName == null || node.tagName != \"LI\") && node.parentNode) {\n        node = node.parentNode;\n      }\n      if (node.nextSibling == null) {\n        node.parentNode.appendChild(li);\n      } else {\n        node.parentNode.insertBefore(li, node.nextSibling);\n      }\n      try {\n        li.focus();\n      } catch (e) {\n        // prevent issue on polyfill browsers potentially\n      }\n    }\n  }\n  _outdent() {\n    this.__blockScrub = true;\n    try {\n      let node = this.getSelectionNode();\n      if (node == null) {\n        return false;\n      }\n      // need to hold this in case it's empty at the end\n      const parent = node.parentNode;\n      if (\n        node.parentNode &&\n        node.parentNode != this.__outlineNode &&\n        node.parentNode.nextSibling != null\n      ) {\n        node.parentNode.parentNode.insertBefore(\n          node,\n          node.parentNode.nextSibling\n        );\n        if (parent.children.length == 0) {\n          parent.remove();\n        }\n      } else if (\n        node.parentNode &&\n        node.parentNode != this.__outlineNode &&\n        node.parentNode.nextSibling == null\n      ) {\n        node.parentNode.parentNode.appendChild(node);\n        if (parent.children.length == 0) {\n          parent.remove();\n        }\n      }\n      node.focus();\n    } catch (e) {\n      console.warn(e);\n    }\n  }\n  _indent() {\n    this.__blockScrub = true;\n    try {\n      let node = this.getSelectionNode();\n      if (node == null) {\n        return false;\n      }\n      // see if the previous tag is a LI, if so we can indent\n      if (\n        node.previousSibling != null &&\n        node.previousSibling.tagName === \"LI\"\n      ) {\n        let ul;\n        if (node.nextSibling && node.nextSibling.tagName === \"UL\") {\n          ul = node.nextSibling;\n        } else {\n          ul = document.createElement(\"ul\");\n          node.parentNode.insertBefore(ul, node);\n        }\n        // append a new list inside the child before the active node position\n        // now append into that list the node that was active\n        ul.appendChild(node);\n        node.focus();\n      } else if (\n        node.previousSibling != null &&\n        node.previousSibling.tagName === \"UL\"\n      ) {\n        node.previousSibling.appendChild(node);\n        node.focus();\n      }\n    } catch (e) {\n      console.warn(e);\n    }\n  }\n  getSelectionNode() {\n    let node = this.getDeepSelection().anchorNode;\n    if (\n      node &&\n      (node.tagName == null || node.tagName != \"LI\") &&\n      node.parentNode\n    ) {\n      node = node.parentNode;\n    }\n    return node;\n  }\n  /**\n   * Selection normalizer\n   */\n  getDeepSelection() {\n    // try and obtain the selection from the nearest shadow\n    // which would give us the selection object when running native ShadowDOM\n    // with fallback support for the entire window which would imply Shady\n    // native API\n    if (this.shadowRoot.getSelection) {\n      return this.shadowRoot.getSelection();\n    }\n    // ponyfill from google\n    else if (getRange(this.__outlineNode.parentNode)) {\n      return getRange(this.__outlineNode.parentNode);\n    }\n    // missed on both, hope the normal one will work\n    return window.getSelection();\n  }\n  /**\n   * Get a normalized range based on current selection\n   */\n  getDeepRange() {\n    let sel = this.getDeepSelection();\n    if (sel.getRangeAt && sel.rangeCount) {\n      return sel.getRangeAt(0);\n    } else if (sel) {\n      return sel;\n    } else false;\n  }\n}\nwindow.customElements.define(EditableOutline.tag, EditableOutline);\nexport { EditableOutline };\n"],"names":["EditableOutline","items","editMode","jos","window","JSONOutlineSchema","requestAvailability","setTimeout","addEventListener","_this","_collapseClickHandler","bind","LitElement","html","this","_enterPressed","_upPressed","_downPressed","buttonEvents","css","Array","Boolean","Object","e","node","getSelectionNode","tagName","nextElementSibling","classList","toggle","shadowRoot","querySelectorAll","forEach","el","remove","add","key","shiftKey","_tabBackKeyPressed","_tabKeyPressed","i","notFound","path","length","parent","parentNode","children","__outlineNode","querySelector","target","_this2","_onKeyDown","_observer","MutationObserver","_observeRecord","observe","childList","subtree","changedProperties","oldValue","propName","includes","eventName","replace","toLowerCase","_this3","dispatchEvent","CustomEvent","detail","value","record","index","info","addedNodes","__blockScrub","setAttribute","scrubElementJOSData","_this4","removeEventListener","disconnect","id","_add","_collapse","_collapseall","_expandall","_indent","_outdent","_move","_duplicate","_delete","activeItem","clone2","cloneNode","insertBefore","clone","console","log","direction","test","valid","previousElementSibling","focus","_this5","firstChild","removeChild","outline","itemsToNodes","appendChild","save","nodesToItems","previousSibling","nextSibling","preventDefault","stopPropagation","stopImmediatePropagation","keyboardEvent","li","document","createElement","warn","ul","getDeepSelection","anchorNode","getSelection","getRange","sel","getRangeAt","rangeCount","customElements","define","tag"],"mappings":"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"}