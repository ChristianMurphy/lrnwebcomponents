{"version":3,"file":"editable-outline.umd.js","sources":["lib/shadows-safari.js","editable-outline.umd.js"],"sourcesContent":["/**\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n\nconst debug = false;\n\nconst validNodeTypes = [\n  Node.ELEMENT_NODE,\n  Node.TEXT_NODE,\n  Node.DOCUMENT_FRAGMENT_NODE\n];\nfunction isValidNode(node) {\n  return validNodeTypes.includes(node.nodeType);\n}\n\nfunction findNode(s, parentNode, isLeft) {\n  const nodes = parentNode.childNodes || parentNode.children;\n  if (!nodes) {\n    return parentNode; // found it, probably text\n  }\n\n  for (let i = 0; i < nodes.length; ++i) {\n    const j = isLeft ? i : nodes.length - 1 - i;\n    const childNode = nodes[j];\n    if (!isValidNode(childNode)) {\n      continue;\n    }\n\n    debug && console.debug(\"checking child\", childNode, \"IsLeft\", isLeft);\n    if (s.containsNode(childNode, true)) {\n      if (s.containsNode(childNode, false)) {\n        debug && console.info(\"found child\", childNode);\n        return childNode;\n      }\n      debug && console.info(\"descending child\", childNode);\n      return findNode(s, childNode, isLeft);\n    }\n    debug && console.info(parentNode, \"does NOT contain\", childNode);\n  }\n  return parentNode;\n}\n\n/**\n * @param {function(!Event)} fn to add to selectionchange internals\n */\nconst addInternalListener = (() => {\n  const testNode = document.createElement(\"div\");\n  const testRoot = testNode.attachShadow({ mode: \"open\" });\n  if (testRoot.getSelection) {\n    // getSelection really exists, why are you using us?\n    document.addEventListener(\"selectionchange\", ev => {\n      document.dispatchEvent(new CustomEvent(\"-shadow-selectionchange\"));\n    });\n    return () => {};\n  }\n\n  let withinInternals = false;\n  const handlers = [];\n\n  document.addEventListener(\"selectionchange\", ev => {\n    if (withinInternals) {\n      return;\n    }\n    document.dispatchEvent(new CustomEvent(\"-shadow-selectionchange\"));\n    withinInternals = true;\n    window.setTimeout(() => {\n      withinInternals = false;\n    }, 0);\n    handlers.forEach(fn => fn(ev));\n  });\n\n  return fn => handlers.push(fn);\n})();\n\nlet wasCaret = false;\nlet resolveTask = null;\naddInternalListener(ev => {\n  const s = window.getSelection();\n  if (s.type === \"Caret\") {\n    wasCaret = true;\n  } else if (wasCaret && !resolveTask) {\n    resolveTask = Promise.resolve(true).then(() => {\n      wasCaret = false;\n      resolveTask = null;\n    });\n  }\n});\n\n/**\n * @param {!Selection} s the window selection to use\n * @param {!Node} node the node to walk from\n * @param {boolean} walkForward should this walk in natural direction\n * @return {boolean} whether the selection contains the following node (even partially)\n */\nfunction containsNextElement(s, node, walkForward) {\n  const start = node;\n  while ((node = walkFromNode(node, walkForward))) {\n    // walking (left) can contain our own parent, which we don't want\n    if (!node.contains(start)) {\n      break;\n    }\n  }\n  if (!node) {\n    return false;\n  }\n  // we look for Element as .containsNode says true for _every_ text node, and we only care about\n  // elements themselves\n  return node instanceof Element && s.containsNode(node, true);\n}\n\n/**\n * @param {!Selection} s the window selection to use\n * @param {!Node} leftNode the left node\n * @param {!Node} rightNode the right node\n * @return {boolean|undefined} whether this has natural direction\n */\nfunction getSelectionDirection(s, leftNode, rightNode) {\n  if (s.type !== \"Range\") {\n    return undefined; // no direction\n  }\n  const measure = () => s.toString().length;\n\n  const initialSize = measure();\n  debug && console.info(`initial selection: \"${s.toString()}\"`);\n\n  if (initialSize === 1 && wasCaret && leftNode === rightNode) {\n    // nb. We need to reset a single selection as Safari _always_ tells us the cursor was dragged\n    // left to right (maybe RTL on those devices).\n    // To be fair, Chrome has the same bug.\n    debug && console.debug(\"resetting size=1\");\n    s.extend(leftNode, 0);\n    s.collapseToEnd();\n    return undefined;\n  }\n\n  let updatedSize;\n\n  // Try extending forward and seeing what happens.\n  s.modify(\"extend\", \"forward\", \"character\");\n  updatedSize = measure();\n  debug && console.info(`forward selection: \"${s.toString()}\"`);\n\n  if (updatedSize > initialSize || containsNextElement(s, rightNode, true)) {\n    debug && console.info(\"got forward >, moving right\");\n    s.modify(\"extend\", \"backward\", \"character\");\n    return true;\n  } else if (updatedSize < initialSize || !s.containsNode(leftNode)) {\n    debug && console.info(\"got forward <, moving left\");\n    s.modify(\"extend\", \"backward\", \"character\");\n    return false;\n  }\n\n  // Maybe we were at the end of something. Extend backwards.\n  // TODO(samthor): We seem to be able to get away without the 'backwards' case.\n  s.modify(\"extend\", \"backward\", \"character\");\n  updatedSize = measure();\n  debug && console.info(`backward selection: \"${s.toString()}\"`);\n\n  if (updatedSize > initialSize || containsNextElement(s, leftNode, false)) {\n    debug && console.info(\"got backwards >, moving left\");\n    s.modify(\"extend\", \"forward\", \"character\");\n    return false;\n  } else if (updatedSize < initialSize || !s.containsNode(rightNode)) {\n    debug && console.info(\"got backwards <, moving right\");\n    s.modify(\"extend\", \"forward\", \"character\");\n    return true;\n  }\n\n  // This is likely a select-all.\n  return undefined;\n}\n\n/**\n * Returns the next valid node (element or text). This is needed as Safari doesn't support\n * TreeWalker inside Shadow DOM. Don't escape shadow roots.\n *\n * @param {!Node} node to start from\n * @param {boolean} walkForward should this walk in natural direction\n * @return {Node} node found, if any\n */\nfunction walkFromNode(node, walkForward) {\n  if (!walkForward) {\n    return node.previousSibling || node.parentNode || null;\n  }\n  while (node) {\n    if (node.nextSibling) {\n      return node.nextSibling;\n    }\n    node = node.parentNode;\n  }\n  return null;\n}\n\n/**\n * @param {!Node} node to start from\n * @param {boolean} isLeft is this a left node\n * @param {string} s expected string\n * @return {?{node: !Node, offset: number}}\n */\nfunction walkTextFromNode(node, isLeft, s) {\n  for (; node; node = walkFromNode(node, isLeft)) {\n    if (node.nodeType !== Node.TEXT_NODE) {\n      continue;\n    }\n\n    const t = node.textContent;\n    if (isLeft) {\n      if (s.length < t.length) {\n        return { node, offset: s.length };\n      }\n\n      const prefix = s.substr(0, t.length);\n      if (prefix !== t) {\n        console.debug(\"unexpected string prefix\", prefix, \"expected\", t);\n      }\n\n      s = s.substr(t.length);\n    } else {\n      if (s.length < t.length) {\n        return { node, offset: t.length - s.length };\n      }\n\n      const suffix = s.substr(s.length - t.length);\n      if (suffix !== t) {\n        console.debug(\"unexpected string suffix\", suffix, \"expected\", t);\n      }\n\n      s = s.substr(0, s.length - t.length);\n    }\n  }\n\n  return null; // too far\n}\n\n/**\n * @param {!Node} node\n * @return {number} count of initial space\n */\nfunction initialSpace(node) {\n  if (node.nodeType !== Node.TEXT_NODE) {\n    return 0;\n  }\n  return /^\\s*/.exec(node.textContent)[0].length;\n}\n\n/**\n * @param {!Node} node\n * @return {number} count of ignored trailing space\n */\nfunction ignoredTrailingSpace(node) {\n  if (node.nodeType !== Node.TEXT_NODE) {\n    return 0;\n  }\n  const trailingSpaceCount = /\\s*$/.exec(node.textContent)[0].length;\n  if (!trailingSpaceCount) {\n    return 0;\n  }\n  return trailingSpaceCount - 1; // always allow single last\n}\n\nconst cachedRange = new Map();\nexport function getRange(root) {\n  if (root.getSelection) {\n    const s = root.getSelection();\n    return s.rangeCount ? s.getRangeAt(0) : null;\n  }\n\n  const thisFrame = cachedRange.get(root);\n  if (thisFrame) {\n    return thisFrame;\n  }\n\n  const initialText = window.getSelection().toString();\n  const result = internalGetShadowSelection(root);\n  const rs = (result.range && result.range.toString()) || null;\n  if (rs !== null && rs !== initialText) {\n    // TODO: sometimes triggers on single-char hack etc\n\n    if (rs.replace(/\\s/g, \"\") !== initialText.replace(/\\s/g, \"\")) {\n      // nb. selection eats initial/ending space, range does not: if whitespace is the only\n      // difference, then ignore\n      console.warn(\"invalid range, initial text:\", initialText);\n      console.warn(\"vs\", rs, result.mode, result.range);\n    }\n  }\n\n  cachedRange.set(root, result.range);\n  window.setTimeout(() => {\n    cachedRange.delete(root);\n  }, 0);\n  debug && console.debug(\"getRange got\", result);\n  return result.range;\n}\n\nconst fakeSelectionNode = document.createTextNode(\"\");\nexport function internalGetShadowSelection(root) {\n  const range = document.createRange();\n\n  const s = window.getSelection();\n  if (!s.containsNode(root.host, true)) {\n    return { range: null, mode: \"none\" };\n  }\n\n  // TODO: inserting fake nodes isn't ideal, but containsNode doesn't work on nearby adjacent\n  // text nodes (in fact it returns true for all text nodes on the page?!).\n\n  // insert a fake 'before' node to see if it's selected\n  root.insertBefore(fakeSelectionNode, root.childNodes[0]);\n  const includesBeforeRoot = s.containsNode(fakeSelectionNode);\n  fakeSelectionNode.remove();\n  if (includesBeforeRoot) {\n    return { range: null, mode: \"outside-before\" };\n  }\n\n  // insert a fake 'after' node to see if it's selected\n  root.appendChild(fakeSelectionNode);\n  const includesAfterRoot = s.containsNode(fakeSelectionNode);\n  fakeSelectionNode.remove();\n  if (includesAfterRoot) {\n    return { range: null, mode: \"outside-after\" };\n  }\n\n  const measure = () => s.toString().length;\n  const initialSelectionContent = s.toString();\n  if (!(s.type === \"Caret\" || s.type === \"Range\")) {\n    throw new TypeError(\"unexpected type: \" + s.type);\n  }\n  const initialCaret = s.type === \"Caret\";\n\n  const leftNode = findNode(s, root, true);\n  let rightNode;\n  let isNaturalDirection = undefined;\n  if (s.type === \"Range\") {\n    rightNode = findNode(s, root, false); // get right node here _before_ getSelectionDirection\n    isNaturalDirection = getSelectionDirection(s, leftNode, rightNode);\n    // isNaturalDirection means \"going right\"\n  }\n\n  if (s.type === \"Caret\") {\n    // we might transition to being a caret, so don't check initial value\n    s.extend(leftNode, 0);\n    const at = measure();\n    s.collapseToEnd();\n\n    range.setStart(leftNode, at);\n    range.setEnd(leftNode, at);\n    return { range, mode: \"caret\" };\n  } else if (isNaturalDirection === undefined) {\n    if (s.type !== \"Range\") {\n      throw new TypeError(\"unexpected type: \" + s.type);\n    }\n    // This occurs when we can't move because we can't extend left or right to measure the\n    // direction we're moving in. Good news though: we don't need to _change_ the selection\n    // to measure it, so just return immediately.\n    range.setStart(leftNode, 0);\n    range.setEnd(rightNode, rightNode.length);\n    return { range, mode: \"all\" };\n  }\n\n  const size = measure();\n  let offsetLeft, offsetRight;\n\n  // only one newline/space char is cared about\n  const validRightLength = rightNode.length - ignoredTrailingSpace(rightNode);\n\n  if (isNaturalDirection) {\n    // walk in the opposite direction first\n    s.extend(leftNode, 0);\n    offsetLeft = measure() + initialSpace(leftNode); // measure doesn't include initial space\n\n    // then in our actual direction\n    s.extend(rightNode, validRightLength);\n    offsetRight = validRightLength - (measure() - size);\n\n    // then revert to the original position\n    s.extend(rightNode, offsetRight);\n  } else {\n    // walk in the opposite direction first\n    s.extend(rightNode, validRightLength);\n    offsetRight = validRightLength - measure();\n\n    // then in our actual direction\n    s.extend(leftNode, 0);\n    offsetLeft = measure() - size + initialSpace(leftNode); // doesn't include initial space\n\n    // then revert to the original position\n    s.extend(leftNode, offsetLeft);\n  }\n\n  if (debug) {\n    if (leftNode === rightNode) {\n      console.info(\n        \"got string\",\n        leftNode.textContent.substr(offsetLeft, offsetRight - offsetLeft)\n      );\n    } else {\n      console.info(\">>> string\", leftNode.textContent.substr(offsetLeft));\n      console.info(\"<<< string\", rightNode.textContent.substr(0, offsetRight));\n    }\n  }\n\n  range.setStart(leftNode, offsetLeft);\n  range.setEnd(rightNode, offsetRight);\n  return {\n    mode: isNaturalDirection ? \"right\" : \"left\",\n    range\n  };\n}\n","/**\n * Copyright 2019 The Pennsylvania State University\n * @license Apache-2.0, see License.md for full text.\n */\nimport { html, PolymerElement } from \"@polymer/polymer/polymer-element.js\";\nimport { getRange } from \"./lib/shadows-safari.js\";\nimport \"@polymer/iron-a11y-keys/iron-a11y-keys.js\";\nimport \"@polymer/iron-icon/iron-icon.js\";\nimport \"@polymer/iron-icons/iron-icons.js\";\nimport \"@polymer/iron-icons/editor-icons.js\";\nimport \"@lrnwebcomponents/json-outline-schema/json-outline-schema.js\";\n\n/**\n * `editable-outline`\n * `a simple outline thats contenteditable in nature`\n *\n * @microcopy - language worth noting:\n *  -\n *\n * @customElement\n * @polymer\n * @demo demo/index.html\n */\nclass EditableOutline extends PolymerElement {\n  \n  // render function\n  static get template() {\n    return html`\n<style>\n:host {\n  display: block;\n  font-family: 'Noto Serif', serif;\n}\n\n:host([hidden]) {\n  display: none;\n}\n\n.button-wrapper {\n  line-height: 36px;\n  position: -webkit-sticky;\n  position: sticky;\n  top: 0px;\n  background-color: white;\n  display: block;\n  justify-content: space-evenly;\n  @apply --editable-outline-button-wrapper;\n}\n@media (max-width: 1000px) {\n  .button-wrapper {\n    @apply --editable-outline-button-wrapper-mobile;\n  }\n  button span {\n    opacity: 0;\n    visibility: hidden;\n    position: absolute;\n    left: -9999px;\n  }\n}\nbutton {\n  height: 32px;\n  font-size: 10px;\n  margin: 0;\n  padding: 0 8px;\n}\n\nbutton span {\n  padding-left: 4px;\n  pointer-events: none;\n}\n\n#outline {\n  margin: 0;\n}\nul {\n  font-size: 16px;\n  line-height: 32px;\n  padding-left: 32px;\n  visibility: visible;\n  opacity: 1;\n  overflow: hidden;\n  height: auto;\n  transition: .2s ease-in-out all;\n  @apply --editable-outline-button-list;\n}\nli {\n  font-size: 16px;\n  line-height: 32px;\n  padding: 4px;\n  transition: .2s linear all;\n  @apply --editable-outline-button-list-item;\n}\nul:hover {\n  outline: 1px solid #EEEEEE;\n}\nli.collapsed-title {\n  background-color: #dddddd;\n}\nli.collapsed-title:after {\n  content:\"    ( Double-click to expand )\";\n}\nli:after {\n  transition: .4s ease-in-out all;\n  opacity: 0;\n  font-size: 11px;\n  visibility: hidden;\n}\nli.collapsed-title:hover:after {\n  font-style: italic;\n  opacity: 1;\n  visibility: visible;\n}\nul.collapsed-content {\n  visibility: hidden;\n  opacity: 0;\n  height: 0;\n}\nli:focus,\nli:active,\nli:hover {\n  background-color: #EEEEEE;\n  outline: 1px solid #CCCCCC;\n  @apply --editable-outline-button-list-item-active;\n}\n\niron-icon {\n  pointer-events: none;\n}\n        </style>\n<iron-a11y-keys target=\"[[__outlineNode]]\" keys=\"shift+tab\" on-keys-pressed=\"_tabBackKeyPressed\"\n  stop-keyboard-event-propagation></iron-a11y-keys>\n<iron-a11y-keys target=\"[[__outlineNode]]\" keys=\"tab\" on-keys-pressed=\"_tabKeyPressed\"\n  stop-keyboard-event-propagation></iron-a11y-keys>\n<iron-a11y-keys target=\"[[__outlineNode]]\" keys=\"enter\" on-keys-pressed=\"_enterPressed\"\n  stop-keyboard-event-propagation></iron-a11y-keys>\n<iron-a11y-keys target=\"[[__outlineNode]]\" keys=\"up\" on-keys-pressed=\"_upPressed\"\n  stop-keyboard-event-propagation></iron-a11y-keys>\n<iron-a11y-keys target=\"[[__outlineNode]]\" keys=\"down\" on-keys-pressed=\"_downPressed\"\n  stop-keyboard-event-propagation></iron-a11y-keys>\n<div class=\"button-wrapper\">\n<button on-click=\"buttonEvents\" id=\"add\" title=\"Add a new node\">\n  <iron-icon icon=\"icons:add\"></iron-icon><span>Add</span>\n</button>\n<button on-click=\"buttonEvents\" id=\"collapse\" title=\"Toggle active node collapsed status\">\n  <iron-icon icon=\"icons:swap-vert\"></iron-icon><span>Toggle active</span>\n</button>\n<button on-click=\"buttonEvents\" id=\"collapseall\" title=\"Collapse all nodes\">\n  <iron-icon icon=\"icons:swap-vert\"></iron-icon><span>Collapse all</span>\n</button>\n<button on-click=\"buttonEvents\" id=\"expandall\" title=\"Expand all nodes\">\n  <iron-icon icon=\"icons:swap-vert\"></iron-icon><span>Expand all</span>\n</button>\n<button on-click=\"buttonEvents\" id=\"down\" title=\"Move active node down\">\n  <iron-icon icon=\"icons:arrow-downward\"></iron-icon><span>Move down</span>\n</button>\n<button on-click=\"buttonEvents\" id=\"up\" title=\"Move active node up\">\n  <iron-icon icon=\"icons:arrow-upward\"></iron-icon><span>Move up</span>\n</button>\n<button on-click=\"buttonEvents\" id=\"outdent\" title=\"Outdent active node\">\n  <iron-icon icon=\"editor:format-indent-decrease\"></iron-icon><span>Outdent</span>\n</button>\n<button on-click=\"buttonEvents\" id=\"indent\" title=\"Indent active node\">\n  <iron-icon icon=\"editor:format-indent-increase\"></iron-icon><span>Indent</span>\n</button>\n<button on-click=\"buttonEvents\" id=\"duplicate\" title=\"Duplicate active node tree\">\n  <iron-icon icon=\"icons:content-copy\"></iron-icon><span>Duplicate</span>\n</button>\n<button on-click=\"buttonEvents\" id=\"delete\" title=\"Delete active node\">\n  <iron-icon icon=\"icons:delete\"></iron-icon><span>Delete</span>\n</button>\n</div>\n<ul id=\"outline\"></ul>`;\n  }\n\n  // properties available to the custom element for data binding\n    static get properties() {\n    return {\n  \n  ...super.properties,\n  \n  /**\n   * A items list of JSON Outline Schema Items\n   */\n  \"items\": {\n    \"name\": \"items\",\n    \"type\": Array,\n    \"value\": [],\n    \"notify\": true\n  },\n  /**\n   * Edit mode\n   */\n  \"editMode\": {\n    \"name\": \"editMode\",\n    \"type\": Boolean,\n    \"notify\": true,\n    \"observer\": \"_editModeChanged\"\n  },\n  /**\n   * Outline node for keyboard key binding\n   */\n  \"__outlineNode\": {\n    \"name\": \"__outlineNode\",\n    \"type\": Object\n  }\n}\n;\n  }\n  constructor() {\n    super();\n    this.jos = window.JSONOutlineSchema.requestAvailability();\n    this.addEventListener(\"dblclick\", this._collapseClickHandler.bind(this));\n  }\n  /**\n   * Store the tag name to make it easier to obtain directly.\n   * @notice function name must be here for tooling to operate correctly\n   */\n  static get tag() {\n    return \"editable-outline\";\n  }\n  /**\n   * Collapse button callback\n   */\n  _collapse(e) {\n    let node = this.getSelectionNode();\n    if (\n      node &&\n      node.tagName === \"LI\" &&\n      node.nextElementSibling &&\n      node.nextElementSibling.tagName === \"UL\"\n    ) {\n      node.classList.toggle(\"collapsed-title\");\n      node.nextElementSibling.classList.toggle(\"collapsed-content\");\n    }\n  }\n  /**\n   * Expand all items\n   */\n  _expandall(e) {\n    this.shadowRoot.querySelectorAll(\"li\").forEach(el => {\n      el.classList.remove(\"collapsed-title\");\n    });\n    this.shadowRoot.querySelectorAll(\"ul\").forEach(el => {\n      el.classList.remove(\"collapsed-content\");\n    });\n  }\n  /**\n   * Collapse all items\n   */\n  _collapseall(e) {\n    this.shadowRoot.querySelectorAll(\"li\").forEach(el => {\n      if (el.nextElementSibling && el.nextElementSibling.tagName === \"UL\") {\n        el.classList.add(\"collapsed-title\");\n        el.nextElementSibling.classList.add(\"collapsed-content\");\n      }\n    });\n  }\n  /**\n   * Click handler method needs to walk a little different then normal collapse\n   */\n  _collapseClickHandler(e) {\n    let el;\n    let i = 0;\n    let notFound = true;\n    while (notFound && e.path.length > i + 1) {\n      el = e.path[i];\n      if (\n        el.tagName === \"LI\" &&\n        el.nextElementSibling &&\n        el.nextElementSibling.tagName === \"UL\"\n      ) {\n        el.classList.toggle(\"collapsed-title\");\n        el.nextElementSibling.classList.toggle(\"collapsed-content\");\n        notFound = false;\n      }\n      i++;\n    }\n  }\n  /**\n   * delete active\n   */\n  _delete(e) {\n    let node = this.getSelectionNode();\n    if (node) {\n      const parent = node.parentNode;\n      node.remove();\n      if (parent.children.length === 0) {\n        parent.remove();\n      }\n    }\n  }\n  /**\n   * life cycle, element is afixed to the DOM\n   */\n  connectedCallback() {\n    super.connectedCallback();\n    this.__outlineNode = this.shadowRoot.querySelector(\"#outline\");\n    this._observer = new MutationObserver(this._observer.bind(this));\n    this._observer.observe(this.__outlineNode, {\n      childList: true,\n      subtree: true\n    });\n  }\n  /**\n   * Mutation observer callback\n   * @todo current issue if you copy and paste into the same node\n   */\n  _observer(record) {\n    let reference;\n    for (var index in record) {\n      let info = record[index];\n      // if we've got new nodes to react to that were not imported\n      if (info.addedNodes.length > 0) {\n        // special rules for an outdent event\n        for (let i in info.addedNodes) {\n          if (info.addedNodes[i].tagName) {\n            if (info.addedNodes[i].tagName === \"LI\") {\n              if (this.__blockScrub) {\n                info.addedNodes[i].setAttribute(\"contenteditable\", \"true\");\n              } else {\n                this.jos.scrubElementJOSData(info.addedNodes[i]);\n                info.addedNodes[i].setAttribute(\"contenteditable\", \"true\");\n              }\n            }\n            // we have an unknown hest of items, scrub em all if we are in scrub mode\n            else if (info.addedNodes[i].tagName === \"UL\") {\n              if (!this.__blockScrub) {\n                this.jos.scrubElementJOSData(info.addedNodes[i]);\n              }\n            }\n          }\n        }\n      }\n    }\n    setTimeout(() => {\n      this.__blockScrub = false;\n    }, 100);\n  }\n  /**\n   * Disconnected life cycle\n   */\n  disconnectedCallback() {\n    super.disconnectedCallback();\n  }\n\n  // Observer editMode for changes\n  _editModeChanged(newValue, oldValue) {\n    if (typeof newValue !== typeof undefined) {\n    }\n  }\n  /**\n   * Button events internally\n   */\n  buttonEvents(e) {\n    switch (e.target.id) {\n      case \"add\":\n        this._add(e);\n        break;\n      case \"collapse\":\n        this._collapse(e);\n        break;\n      case \"collapseall\":\n        this._collapseall(e);\n        break;\n      case \"expandall\":\n        this._expandall(e);\n        break;\n      case \"indent\":\n        this._indent();\n        break;\n      case \"outdent\":\n        this._outdent();\n        break;\n      case \"up\":\n        this._move(\"up\");\n        break;\n      case \"down\":\n        this._move(\"down\");\n        break;\n      case \"duplicate\":\n        this._duplicate();\n        break;\n      case \"delete\":\n        this._delete();\n        break;\n    }\n  }\n  /**\n   * Duplicate whatever has selection\n   */\n  _duplicate() {\n    // get active item from where cursor is\n    try {\n      this.__blockScrub = false;\n      let activeItem = this.getSelectionNode();\n      if (activeItem && activeItem.tagName === \"LI\") {\n        // clone the item's hierarchy as well\n        if (\n          activeItem.nextElementSibling !== null &&\n          activeItem.nextElementSibling.tagName === \"UL\"\n        ) {\n          // copy the UL and all children and insert it after the UL it's duplicating\n          const clone2 = activeItem.nextElementSibling.cloneNode(true);\n          activeItem.parentNode.insertBefore(\n            clone2,\n            activeItem.nextElementSibling.nextElementSibling\n          );\n          // clone the LI, placing it before the UL we just made\n          const clone = activeItem.cloneNode(true);\n          activeItem.parentNode.insertBefore(\n            clone,\n            activeItem.nextElementSibling.nextElementSibling\n          );\n        } else {\n          const clone = activeItem.cloneNode(true);\n          // insert the clone AFTER the current selection\n          activeItem.parentNode.insertBefore(\n            clone,\n            activeItem.nextElementSibling\n          );\n        }\n      }\n    } catch (e) {\n      console.log(e);\n    }\n  }\n  /**\n   * Move whatever has selection up or down\n   */\n  _move(direction) {\n    // get active item from where cursor is\n    try {\n      let activeItem = this.getSelectionNode();\n      let test = activeItem;\n      let valid = false;\n      if (activeItem == null) {\n        return false;\n      }\n      // ensure this operation is executed in scope\n      while (!valid && test.parentNode) {\n        if (test.id === \"outline\") {\n          valid = true;\n        }\n        test = test.parentNode;\n      }\n      // ensure from all that, we have something\n      if (valid && activeItem && activeItem.tagName === \"LI\") {\n        // move the things above us, below us\n        if (direction === \"up\") {\n          // ensure there's something above us\n          if (activeItem.previousElementSibling !== null) {\n            // see if we are moving us, or us and the hierarchy\n            if (\n              activeItem.nextElementSibling &&\n              activeItem.nextElementSibling.tagName === \"UL\"\n            ) {\n              // see if the thing we have to move above has it's own structure\n              if (activeItem.previousElementSibling.tagName === \"UL\") {\n                // ensure we don't lose our metadata\n                this.__blockScrub = true;\n                // insert the element currently above us, just before 2 places back; so behind our UL\n                activeItem.parentNode.insertBefore(\n                  activeItem.previousElementSibling,\n                  activeItem.nextElementSibling.nextElementSibling\n                );\n              }\n              this.__blockScrub = true;\n              // now insert the LI above us, 2 places back so it is in front of the UL\n              activeItem.parentNode.insertBefore(\n                activeItem.previousElementSibling,\n                activeItem.nextElementSibling.nextElementSibling\n              );\n              activeItem.focus();\n            } else {\n              // easier use case, we are moving ourselves only but above us is a UL\n              if (activeItem.previousElementSibling.tagName === \"UL\") {\n                this.__blockScrub = true;\n                // move the UL after us\n                activeItem.parentNode.insertBefore(\n                  activeItem.previousElementSibling,\n                  activeItem.nextElementSibling\n                );\n              }\n              this.__blockScrub = true;\n              // now move the LI after us\n              activeItem.parentNode.insertBefore(\n                activeItem.previousElementSibling,\n                activeItem.nextElementSibling\n              );\n              activeItem.focus();\n            }\n          }\n        } else if (direction === \"down\") {\n          // if nothing after us, we can't move\n          if (activeItem.nextElementSibling !== null) {\n            // account for having to hop over children\n            if (\n              activeItem.nextElementSibling &&\n              activeItem.nextElementSibling.tagName === \"UL\" &&\n              activeItem.nextElementSibling.nextElementSibling !== null\n            ) {\n              // an outline is just below us\n              if (\n                activeItem.nextElementSibling.nextElementSibling.tagName ===\n                  \"LI\" &&\n                activeItem.nextElementSibling.nextElementSibling\n                  .nextElementSibling !== null &&\n                activeItem.nextElementSibling.nextElementSibling\n                  .nextElementSibling.tagName === \"UL\"\n              ) {\n                this.__blockScrub = true;\n                // move the thing 2 down to just before us; so the UL\n                activeItem.parentNode.insertBefore(\n                  activeItem.nextElementSibling.nextElementSibling,\n                  activeItem\n                );\n              }\n              this.__blockScrub = true;\n              // now move the LI that is 2 below us just above us\n              activeItem.parentNode.insertBefore(\n                activeItem.nextElementSibling.nextElementSibling,\n                activeItem\n              );\n              activeItem.focus();\n            } else if (activeItem.nextElementSibling.tagName === \"LI\") {\n              // just moving 1 tag, see if we need to move 2 things about us or 1\n              if (\n                activeItem.nextElementSibling.nextElementSibling !== null &&\n                activeItem.nextElementSibling.nextElementSibling.tagName ===\n                  \"UL\"\n              ) {\n                this.__blockScrub = true;\n                activeItem.parentNode.insertBefore(\n                  activeItem.nextElementSibling,\n                  activeItem\n                );\n              }\n              this.__blockScrub = true;\n              // work on the LI\n              activeItem.parentNode.insertBefore(\n                activeItem.nextElementSibling,\n                activeItem\n              );\n              activeItem.focus();\n            }\n          }\n        }\n      }\n    } catch (e) {\n      console.log(e);\n    }\n  }\n  /**\n   * Take the current manifest and import it into an HTML outline\n   */\n  importJsonOutlineSchemaItems() {\n    this.__blockScrub = true;\n    // wipe out the outline\n    while (this.__outlineNode.firstChild !== null) {\n      this.__outlineNode.removeChild(this.__outlineNode.firstChild);\n    }\n    if (this.items.length === 0) {\n      // get from JOS items if we have none currently\n      this.set(\"items\", this.jos.items);\n    }\n    let outline = this.jos.itemsToNodes(this.items);\n    // rebuild the outline w/ children we just found\n    while (outline.firstChild !== null) {\n      this.__blockScrub = true;\n      this.__outlineNode.appendChild(outline.firstChild);\n    }\n    this.shadowRoot.querySelectorAll(\"li\").forEach(el => {\n      el.setAttribute(\"contenteditable\", \"true\");\n    });\n    return outline;\n  }\n  /**\n   * Take what's currently in the area and get JSON Outline Schema; optionally save\n   */\n  exportJsonOutlineSchemaItems(save = false) {\n    return this.jos.nodesToItems(this.__outlineNode, save);\n  }\n  _upPressed(e) {\n    let node = this.getSelectionNode();\n    if (node && node.previousSibling && node.previousSibling.tagName === \"LI\") {\n      node.previousSibling.focus();\n    } else if (\n      node &&\n      node.previousSibling &&\n      node.previousSibling.tagName === \"UL\" &&\n      node.previousSibling.firstChild &&\n      node.previousSibling.firstChild.tagName === \"LI\"\n    ) {\n      node.previousSibling.firstChild.focus();\n    } else if (\n      node &&\n      node.previousSibling == null &&\n      node.parentNode.tagName === \"UL\" &&\n      node.parentNode.previousSibling &&\n      node.parentNode.previousSibling.tagName === \"LI\"\n    ) {\n      node.parentNode.previousSibling.focus();\n    }\n  }\n  _downPressed(e) {\n    let node = this.getSelectionNode();\n    if (node && node.nextSibling && node.nextSibling.tagName === \"LI\") {\n      node.nextSibling.focus();\n    } else if (\n      node &&\n      node.nextSibling &&\n      node.nextSibling.tagName === \"UL\" &&\n      node.nextSibling.firstChild &&\n      node.nextSibling.firstChild.tagName === \"LI\"\n    ) {\n      node.nextSibling.firstChild.focus();\n    } else if (\n      node &&\n      node.nextSibling == null &&\n      node.parentNode.tagName === \"UL\" &&\n      node.parentNode.nextSibling &&\n      node.parentNode.nextSibling.tagName === \"LI\"\n    ) {\n      node.parentNode.nextSibling.focus();\n    }\n  }\n  /**\n   * Find the next thing to tab forward to.\n   */\n  _tabKeyPressed(e) {\n    e.preventDefault();\n    e.stopPropagation();\n    e.stopImmediatePropagation();\n    if (e.detail.keyboardEvent) {\n      e.detail.keyboardEvent.preventDefault();\n      e.detail.keyboardEvent.stopPropagation();\n      e.detail.keyboardEvent.stopImmediatePropagation();\n    }\n    try {\n      this._indent();\n    } catch (e) {}\n  }\n  /**\n   * Move back through things when tab back pressed\n   */\n  _tabBackKeyPressed(e) {\n    e.preventDefault();\n    e.stopPropagation();\n    e.stopImmediatePropagation();\n    if (e.detail.keyboardEvent) {\n      e.detail.keyboardEvent.preventDefault();\n      e.detail.keyboardEvent.stopPropagation();\n      e.detail.keyboardEvent.stopImmediatePropagation();\n    }\n    try {\n      this._outdent();\n    } catch (e) {}\n  }\n  _enterPressed(e) {\n    e.preventDefault();\n    e.stopPropagation();\n    e.stopImmediatePropagation();\n    // prevent the contenteditable stuff\n    if (e.detail.keyboardEvent) {\n      e.detail.keyboardEvent.preventDefault();\n      e.detail.keyboardEvent.stopPropagation();\n      e.detail.keyboardEvent.stopImmediatePropagation();\n    }\n    this._add();\n  }\n  _add() {\n    let li = document.createElement(\"li\");\n    li.setAttribute(\"contenteditable\", \"true\");\n    let node = this.getSelectionNode();\n    if (\n      this.__outlineNode.querySelector(\"li\") == null ||\n      !node ||\n      (node.tagName && (node.tagName != \"UL\" && node.tagName != \"LI\"))\n    ) {\n      this.__outlineNode.appendChild(li);\n    } else {\n      if ((node.tagName == null || node.tagName != \"LI\") && node.parentNode) {\n        node = node.parentNode;\n      }\n      if (node.nextSibling == null) {\n        node.parentNode.appendChild(li);\n      } else {\n        node.parentNode.insertBefore(li, node.nextSibling);\n      }\n      try {\n        li.focus();\n      } catch (e) {\n        // prevent issue on polyfill browsers potentially\n      }\n    }\n  }\n  _outdent() {\n    this.__blockScrub = true;\n    try {\n      let node = this.getSelectionNode();\n      if (node == null) {\n        return false;\n      }\n      // need to hold this in case it's empty at the end\n      const parent = node.parentNode;\n      if (\n        node.parentNode &&\n        node.parentNode != this.__outlineNode &&\n        node.parentNode.nextSibling != null\n      ) {\n        node.parentNode.parentNode.insertBefore(\n          node,\n          node.parentNode.nextSibling\n        );\n        if (parent.children.length == 0) {\n          parent.remove();\n        }\n      } else if (\n        node.parentNode &&\n        node.parentNode != this.__outlineNode &&\n        node.parentNode.nextSibling == null\n      ) {\n        node.parentNode.parentNode.appendChild(node);\n        if (parent.children.length == 0) {\n          parent.remove();\n        }\n      }\n      node.focus();\n    } catch (e) {\n      console.warn(e);\n    }\n  }\n  _indent() {\n    this.__blockScrub = true;\n    try {\n      let node = this.getSelectionNode();\n      if (node == null) {\n        return false;\n      }\n      // see if the previous tag is a LI, if so we can indent\n      if (\n        node.previousSibling != null &&\n        node.previousSibling.tagName === \"LI\"\n      ) {\n        let ul;\n        if (node.nextSibling && node.nextSibling.tagName === \"UL\") {\n          ul = node.nextSibling;\n        } else {\n          ul = document.createElement(\"ul\");\n          node.parentNode.insertBefore(ul, node);\n        }\n        // append a new list inside the child before the active node position\n        // now append into that list the node that was active\n        ul.appendChild(node);\n        node.focus();\n      } else if (\n        node.previousSibling != null &&\n        node.previousSibling.tagName === \"UL\"\n      ) {\n        node.previousSibling.appendChild(node);\n        node.focus();\n      }\n    } catch (e) {\n      console.warn(e);\n    }\n  }\n  getSelectionNode() {\n    let node = this.getDeepSelection().anchorNode;\n    if (\n      node &&\n      (node.tagName == null || node.tagName != \"LI\") &&\n      node.parentNode\n    ) {\n      node = node.parentNode;\n    }\n    return node;\n  }\n  /**\n   * Selection normalizer\n   */\n  getDeepSelection() {\n    // try and obtain the selection from the nearest shadow\n    // which would give us the selection object when running native ShadowDOM\n    // with fallback support for the entire window which would imply Shady\n    // native API\n    if (this.shadowRoot.getSelection) {\n      return this.shadowRoot.getSelection();\n    }\n    // ponyfill from google\n    else if (getRange(this.__outlineNode.parentNode)) {\n      return getRange(this.__outlineNode.parentNode);\n    }\n    // missed on both, hope the normal one will work\n    return window.getSelection();\n  }\n  /**\n   * Get a normalized range based on current selection\n   */\n  getDeepRange() {\n    let sel = this.getDeepSelection();\n    if (sel.getRangeAt && sel.rangeCount) {\n      return sel.getRangeAt(0);\n    } else if (sel) {\n      return sel;\n    } else false;\n  }\n}\nwindow.customElements.define(EditableOutline.tag, EditableOutline);\nexport { EditableOutline };\n"],"names":["validNodeTypes","Node","ELEMENT_NODE","TEXT_NODE","DOCUMENT_FRAGMENT_NODE","findNode","s","parentNode","isLeft","node","nodes","childNodes","children","i","length","childNode","includes","nodeType","containsNode","addInternalListener","document","createElement","attachShadow","mode","getSelection","addEventListener","ev","dispatchEvent","CustomEvent","withinInternals","handlers","window","setTimeout","forEach","fn","push","wasCaret","resolveTask","containsNextElement","walkForward","start","walkFromNode","contains","Element","previousSibling","nextSibling","initialSpace","exec","textContent","type","Promise","resolve","then","cachedRange","Map","getRange","root","rangeCount","getRangeAt","thisFrame","get","initialText","toString","result","range","createRange","host","insertBefore","fakeSelectionNode","includesBeforeRoot","remove","appendChild","includesAfterRoot","measure","TypeError","rightNode","leftNode","isNaturalDirection","undefined","updatedSize","initialSize","extend","collapseToEnd","modify","getSelectionDirection","at","setStart","setEnd","offsetLeft","offsetRight","size","validRightLength","trailingSpaceCount","ignoredTrailingSpace","internalGetShadowSelection","rs","replace","console","warn","set","delete","createTextNode","EditableOutline","jos","JSONOutlineSchema","requestAvailability","_this","_collapseClickHandler","bind","PolymerElement","html","Array","Boolean","Object","e","this","getSelectionNode","tagName","nextElementSibling","classList","toggle","shadowRoot","querySelectorAll","el","add","notFound","path","parent","__outlineNode","querySelector","_observer","MutationObserver","observe","childList","subtree","record","index","info","addedNodes","__blockScrub","setAttribute","scrubElementJOSData","_this2","newValue","oldValue","_typeof","target","id","_add","_collapse","_collapseall","_expandall","_indent","_outdent","_move","_duplicate","_delete","activeItem","clone2","cloneNode","clone","log","direction","test","valid","previousElementSibling","focus","firstChild","removeChild","items","outline","itemsToNodes","save","nodesToItems","preventDefault","stopPropagation","stopImmediatePropagation","detail","keyboardEvent","li","ul","getDeepSelection","anchorNode","sel","customElements","define","tag"],"mappings":"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"}