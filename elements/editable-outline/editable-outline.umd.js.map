{"version":3,"file":"editable-outline.umd.js","sources":["lib/shadows-safari.js","editable-outline.umd.js"],"sourcesContent":["/**\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n\nconst debug = false;\n\nconst validNodeTypes = [\n  Node.ELEMENT_NODE,\n  Node.TEXT_NODE,\n  Node.DOCUMENT_FRAGMENT_NODE\n];\nfunction isValidNode(node) {\n  return validNodeTypes.includes(node.nodeType);\n}\n\nfunction findNode(s, parentNode, isLeft) {\n  const nodes = parentNode.childNodes || parentNode.children;\n  if (!nodes) {\n    return parentNode; // found it, probably text\n  }\n\n  for (let i = 0; i < nodes.length; ++i) {\n    const j = isLeft ? i : nodes.length - 1 - i;\n    const childNode = nodes[j];\n    if (!isValidNode(childNode)) {\n      continue;\n    }\n\n    debug && console.debug(\"checking child\", childNode, \"IsLeft\", isLeft);\n    if (s.containsNode(childNode, true)) {\n      if (s.containsNode(childNode, false)) {\n        debug && console.info(\"found child\", childNode);\n        return childNode;\n      }\n      debug && console.info(\"descending child\", childNode);\n      return findNode(s, childNode, isLeft);\n    }\n    debug && console.info(parentNode, \"does NOT contain\", childNode);\n  }\n  return parentNode;\n}\n\n/**\n * @param {function(!Event)} fn to add to selectionchange internals\n */\nconst addInternalListener = (() => {\n  const testNode = document.createElement(\"div\");\n  const testRoot = testNode.attachShadow({ mode: \"open\" });\n  if (testRoot.getSelection) {\n    // getSelection really exists, why are you using us?\n    document.addEventListener(\"selectionchange\", ev => {\n      document.dispatchEvent(new CustomEvent(\"-shadow-selectionchange\"));\n    });\n    return () => {};\n  }\n\n  let withinInternals = false;\n  const handlers = [];\n\n  document.addEventListener(\"selectionchange\", ev => {\n    if (withinInternals) {\n      return;\n    }\n    document.dispatchEvent(new CustomEvent(\"-shadow-selectionchange\"));\n    withinInternals = true;\n    window.setTimeout(() => {\n      withinInternals = false;\n    }, 0);\n    handlers.forEach(fn => fn(ev));\n  });\n\n  return fn => handlers.push(fn);\n})();\n\nlet wasCaret = false;\nlet resolveTask = null;\naddInternalListener(ev => {\n  const s = window.getSelection();\n  if (s.type === \"Caret\") {\n    wasCaret = true;\n  } else if (wasCaret && !resolveTask) {\n    resolveTask = Promise.resolve(true).then(() => {\n      wasCaret = false;\n      resolveTask = null;\n    });\n  }\n});\n\n/**\n * @param {!Selection} s the window selection to use\n * @param {!Node} node the node to walk from\n * @param {boolean} walkForward should this walk in natural direction\n * @return {boolean} whether the selection contains the following node (even partially)\n */\nfunction containsNextElement(s, node, walkForward) {\n  const start = node;\n  while ((node = walkFromNode(node, walkForward))) {\n    // walking (left) can contain our own parent, which we don't want\n    if (!node.contains(start)) {\n      break;\n    }\n  }\n  if (!node) {\n    return false;\n  }\n  // we look for Element as .containsNode says true for _every_ text node, and we only care about\n  // elements themselves\n  return node instanceof Element && s.containsNode(node, true);\n}\n\n/**\n * @param {!Selection} s the window selection to use\n * @param {!Node} leftNode the left node\n * @param {!Node} rightNode the right node\n * @return {boolean|undefined} whether this has natural direction\n */\nfunction getSelectionDirection(s, leftNode, rightNode) {\n  if (s.type !== \"Range\") {\n    return undefined; // no direction\n  }\n  const measure = () => s.toString().length;\n\n  const initialSize = measure();\n  debug && console.info(`initial selection: \"${s.toString()}\"`);\n\n  if (initialSize === 1 && wasCaret && leftNode === rightNode) {\n    // nb. We need to reset a single selection as Safari _always_ tells us the cursor was dragged\n    // left to right (maybe RTL on those devices).\n    // To be fair, Chrome has the same bug.\n    debug && console.debug(\"resetting size=1\");\n    s.extend(leftNode, 0);\n    s.collapseToEnd();\n    return undefined;\n  }\n\n  let updatedSize;\n\n  // Try extending forward and seeing what happens.\n  s.modify(\"extend\", \"forward\", \"character\");\n  updatedSize = measure();\n  debug && console.info(`forward selection: \"${s.toString()}\"`);\n\n  if (updatedSize > initialSize || containsNextElement(s, rightNode, true)) {\n    debug && console.info(\"got forward >, moving right\");\n    s.modify(\"extend\", \"backward\", \"character\");\n    return true;\n  } else if (updatedSize < initialSize || !s.containsNode(leftNode)) {\n    debug && console.info(\"got forward <, moving left\");\n    s.modify(\"extend\", \"backward\", \"character\");\n    return false;\n  }\n\n  // Maybe we were at the end of something. Extend backwards.\n  // TODO(samthor): We seem to be able to get away without the 'backwards' case.\n  s.modify(\"extend\", \"backward\", \"character\");\n  updatedSize = measure();\n  debug && console.info(`backward selection: \"${s.toString()}\"`);\n\n  if (updatedSize > initialSize || containsNextElement(s, leftNode, false)) {\n    debug && console.info(\"got backwards >, moving left\");\n    s.modify(\"extend\", \"forward\", \"character\");\n    return false;\n  } else if (updatedSize < initialSize || !s.containsNode(rightNode)) {\n    debug && console.info(\"got backwards <, moving right\");\n    s.modify(\"extend\", \"forward\", \"character\");\n    return true;\n  }\n\n  // This is likely a select-all.\n  return undefined;\n}\n\n/**\n * Returns the next valid node (element or text). This is needed as Safari doesn't support\n * TreeWalker inside Shadow DOM. Don't escape shadow roots.\n *\n * @param {!Node} node to start from\n * @param {boolean} walkForward should this walk in natural direction\n * @return {Node} node found, if any\n */\nfunction walkFromNode(node, walkForward) {\n  if (!walkForward) {\n    return node.previousSibling || node.parentNode || null;\n  }\n  while (node) {\n    if (node.nextSibling) {\n      return node.nextSibling;\n    }\n    node = node.parentNode;\n  }\n  return null;\n}\n\n/**\n * @param {!Node} node to start from\n * @param {boolean} isLeft is this a left node\n * @param {string} s expected string\n * @return {?{node: !Node, offset: number}}\n */\nfunction walkTextFromNode(node, isLeft, s) {\n  for (; node; node = walkFromNode(node, isLeft)) {\n    if (node.nodeType !== Node.TEXT_NODE) {\n      continue;\n    }\n\n    const t = node.textContent;\n    if (isLeft) {\n      if (s.length < t.length) {\n        return { node, offset: s.length };\n      }\n\n      const prefix = s.substr(0, t.length);\n      if (prefix !== t) {\n        console.debug(\"unexpected string prefix\", prefix, \"expected\", t);\n      }\n\n      s = s.substr(t.length);\n    } else {\n      if (s.length < t.length) {\n        return { node, offset: t.length - s.length };\n      }\n\n      const suffix = s.substr(s.length - t.length);\n      if (suffix !== t) {\n        console.debug(\"unexpected string suffix\", suffix, \"expected\", t);\n      }\n\n      s = s.substr(0, s.length - t.length);\n    }\n  }\n\n  return null; // too far\n}\n\n/**\n * @param {!Node} node\n * @return {number} count of initial space\n */\nfunction initialSpace(node) {\n  if (node.nodeType !== Node.TEXT_NODE) {\n    return 0;\n  }\n  return /^\\s*/.exec(node.textContent)[0].length;\n}\n\n/**\n * @param {!Node} node\n * @return {number} count of ignored trailing space\n */\nfunction ignoredTrailingSpace(node) {\n  if (node.nodeType !== Node.TEXT_NODE) {\n    return 0;\n  }\n  const trailingSpaceCount = /\\s*$/.exec(node.textContent)[0].length;\n  if (!trailingSpaceCount) {\n    return 0;\n  }\n  return trailingSpaceCount - 1; // always allow single last\n}\n\nconst cachedRange = new Map();\nexport function getRange(root) {\n  if (root.getSelection) {\n    const s = root.getSelection();\n    return s.rangeCount ? s.getRangeAt(0) : null;\n  }\n\n  const thisFrame = cachedRange.get(root);\n  if (thisFrame) {\n    return thisFrame;\n  }\n\n  const initialText = window.getSelection().toString();\n  const result = internalGetShadowSelection(root);\n  const rs = (result.range && result.range.toString()) || null;\n  if (rs !== null && rs !== initialText) {\n    // TODO: sometimes triggers on single-char hack etc\n\n    if (rs.replace(/\\s/g, \"\") !== initialText.replace(/\\s/g, \"\")) {\n      // nb. selection eats initial/ending space, range does not: if whitespace is the only\n      // difference, then ignore\n      console.warn(\"invalid range, initial text:\", initialText);\n      console.warn(\"vs\", rs, result.mode, result.range);\n    }\n  }\n\n  cachedRange.set(root, result.range);\n  window.setTimeout(() => {\n    cachedRange.delete(root);\n  }, 0);\n  debug && console.debug(\"getRange got\", result);\n  return result.range;\n}\n\nconst fakeSelectionNode = document.createTextNode(\"\");\nexport function internalGetShadowSelection(root) {\n  const range = document.createRange();\n\n  const s = window.getSelection();\n  if (!s.containsNode(root.host, true)) {\n    return { range: null, mode: \"none\" };\n  }\n\n  // TODO: inserting fake nodes isn't ideal, but containsNode doesn't work on nearby adjacent\n  // text nodes (in fact it returns true for all text nodes on the page?!).\n\n  // insert a fake 'before' node to see if it's selected\n  root.insertBefore(fakeSelectionNode, root.childNodes[0]);\n  const includesBeforeRoot = s.containsNode(fakeSelectionNode);\n  fakeSelectionNode.remove();\n  if (includesBeforeRoot) {\n    return { range: null, mode: \"outside-before\" };\n  }\n\n  // insert a fake 'after' node to see if it's selected\n  root.appendChild(fakeSelectionNode);\n  const includesAfterRoot = s.containsNode(fakeSelectionNode);\n  fakeSelectionNode.remove();\n  if (includesAfterRoot) {\n    return { range: null, mode: \"outside-after\" };\n  }\n\n  const measure = () => s.toString().length;\n  const initialSelectionContent = s.toString();\n  if (!(s.type === \"Caret\" || s.type === \"Range\")) {\n    throw new TypeError(\"unexpected type: \" + s.type);\n  }\n  const initialCaret = s.type === \"Caret\";\n\n  const leftNode = findNode(s, root, true);\n  let rightNode;\n  let isNaturalDirection = undefined;\n  if (s.type === \"Range\") {\n    rightNode = findNode(s, root, false); // get right node here _before_ getSelectionDirection\n    isNaturalDirection = getSelectionDirection(s, leftNode, rightNode);\n    // isNaturalDirection means \"going right\"\n  }\n\n  if (s.type === \"Caret\") {\n    // we might transition to being a caret, so don't check initial value\n    s.extend(leftNode, 0);\n    const at = measure();\n    s.collapseToEnd();\n\n    range.setStart(leftNode, at);\n    range.setEnd(leftNode, at);\n    return { range, mode: \"caret\" };\n  } else if (isNaturalDirection === undefined) {\n    if (s.type !== \"Range\") {\n      throw new TypeError(\"unexpected type: \" + s.type);\n    }\n    // This occurs when we can't move because we can't extend left or right to measure the\n    // direction we're moving in. Good news though: we don't need to _change_ the selection\n    // to measure it, so just return immediately.\n    range.setStart(leftNode, 0);\n    range.setEnd(rightNode, rightNode.length);\n    return { range, mode: \"all\" };\n  }\n\n  const size = measure();\n  let offsetLeft, offsetRight;\n\n  // only one newline/space char is cared about\n  const validRightLength = rightNode.length - ignoredTrailingSpace(rightNode);\n\n  if (isNaturalDirection) {\n    // walk in the opposite direction first\n    s.extend(leftNode, 0);\n    offsetLeft = measure() + initialSpace(leftNode); // measure doesn't include initial space\n\n    // then in our actual direction\n    s.extend(rightNode, validRightLength);\n    offsetRight = validRightLength - (measure() - size);\n\n    // then revert to the original position\n    s.extend(rightNode, offsetRight);\n  } else {\n    // walk in the opposite direction first\n    s.extend(rightNode, validRightLength);\n    offsetRight = validRightLength - measure();\n\n    // then in our actual direction\n    s.extend(leftNode, 0);\n    offsetLeft = measure() - size + initialSpace(leftNode); // doesn't include initial space\n\n    // then revert to the original position\n    s.extend(leftNode, offsetLeft);\n  }\n\n  if (debug) {\n    if (leftNode === rightNode) {\n      console.info(\n        \"got string\",\n        leftNode.textContent.substr(offsetLeft, offsetRight - offsetLeft)\n      );\n    } else {\n      console.info(\">>> string\", leftNode.textContent.substr(offsetLeft));\n      console.info(\"<<< string\", rightNode.textContent.substr(0, offsetRight));\n    }\n  }\n\n  range.setStart(leftNode, offsetLeft);\n  range.setEnd(rightNode, offsetRight);\n  return {\n    mode: isNaturalDirection ? \"right\" : \"left\",\n    range\n  };\n}\n","/**\n * Copyright 2019 The Pennsylvania State University\n * @license Apache-2.0, see License.md for full text.\n */\nimport { html, PolymerElement } from \"@polymer/polymer/polymer-element.js\";\nimport { getRange } from \"./lib/shadows-safari.js\";\nimport \"@polymer/iron-a11y-keys/iron-a11y-keys.js\";\nimport \"@polymer/iron-icon/iron-icon.js\";\nimport \"@polymer/iron-icons/iron-icons.js\";\nimport \"@polymer/iron-icons/editor-icons.js\";\nimport \"@lrnwebcomponents/json-outline-schema/json-outline-schema.js\";\n\n/**\n * `editable-outline`\n * `a simple outline thats contenteditable in nature`\n *\n * @microcopy - language worth noting:\n *  -\n *\n * @customElement\n * @polymer\n * @demo demo/index.html\n */\nclass EditableOutline extends PolymerElement {\n  \n  // render function\n  static get template() {\n    return html`\n<style>:host {\n  display: block;\n  font-family: 'Noto Serif', serif;\n}\n\n:host([hidden]) {\n  display: none;\n}\n\n.button-wrapper {\n  background-color: white;\n  position: absolute;\n  display: block;\n  justify-content: space-evenly;\n  @apply --editable-outline-button-wrapper;\n}\n@media (max-width: 1000px) {\n  .button-wrapper {\n    position: relative;\n    @apply --editable-outline-button-wrapper-mobile;\n  }\n}\nbutton {\n  height: 32px;\n  font-size: 10px;\n  margin: 0;\n  padding: 0 8px;\n}\n\n#outline {\n  padding-top: 44px;\n  margin: 0;\n}\nul, ol {\n  font-size: 16px;\n  line-height: 32px;\n  padding-left: 32px;\n  @apply --editable-outline-button-list;\n}\nli {\n  font-size: 16px;\n  line-height: 32px;\n  padding: 4px;\n  @apply --editable-outline-button-list-item;\n}\n\nli:focus,\nli:active,\nli:hover {\n  background-color: #EEEEEE;\n  outline: 1px solid #CCCCCC;\n  @apply --editable-outline-button-list-item-active;\n}\n\niron-icon {\n  pointer-events: none;\n}</style>\n<div class=\"button-wrapper\">\n<button on-click=\"buttonEvents\" id=\"add\">\n  <iron-icon icon=\"icons:add\"></iron-icon> Add\n</button>\n<button on-click=\"buttonEvents\" id=\"down\">\n  <iron-icon icon=\"icons:arrow-downward\"></iron-icon> Move down\n</button>\n<button on-click=\"buttonEvents\" id=\"up\">\n  <iron-icon icon=\"icons:arrow-upward\"></iron-icon> Move up\n</button>\n<button on-click=\"buttonEvents\" id=\"outdent\">\n  <iron-icon icon=\"editor:format-indent-decrease\"></iron-icon> Outdent\n</button>\n<button on-click=\"buttonEvents\" id=\"indent\">\n  <iron-icon icon=\"editor:format-indent-increase\"></iron-icon> Indent\n</button>\n<button on-click=\"buttonEvents\" id=\"duplicate\">\n  <iron-icon icon=\"icons:content-copy\"></iron-icon> Duplicate\n</button>\n</div>\n<ul id=\"outline\" contenteditable$=\"[[editMode]]\">\n  <li contenteditable=\"true\"></li>\n</ul>\n\n<iron-a11y-keys target=\"[[__outlineNode]]\" keys=\"shift+tab\" on-keys-pressed=\"_tabBackKeyPressed\"\n  stop-keyboard-event-propagation></iron-a11y-keys>\n<iron-a11y-keys target=\"[[__outlineNode]]\" keys=\"tab\" on-keys-pressed=\"_tabKeyPressed\"\n  stop-keyboard-event-propagation></iron-a11y-keys>`;\n  }\n\n  // properties available to the custom element for data binding\n    static get properties() {\n    let props = {\n  /**\n   * A items list of JSON Outline Schema Items\n   */\n  \"items\": {\n    \"name\": \"items\",\n    \"type\": Array,\n    \"value\": [],\n    \"notify\": true\n  },\n  /**\n   * Edit mode\n   */\n  \"editMode\": {\n    \"name\": \"editMode\",\n    \"type\": Boolean,\n    \"notify\": true,\n    \"observer\": \"_editModeChanged\"\n  },\n  /**\n   * Outline node for keyboard key binding\n   */\n  \"__outlineNode\": {\n    \"name\": \"__outlineNode\",\n    \"type\": Object\n  }\n}\n;\n    if (super.properties) {\n      props = Object.assign(props, super.properties);\n    }\n    return props;\n  }\n  constructor() {\n    super();\n    this.polyfillSafe = this.__computePolyfillSafe();\n    window.JSONOutlineSchema.requestAvailability();\n  }\n  /**\n   * Store the tag name to make it easier to obtain directly.\n   * @notice function name must be here for tooling to operate correctly\n   */\n  static get tag() {\n    return \"editable-outline\";\n  }\n  /**\n   * life cycle, element is afixed to the DOM\n   */\n  connectedCallback() {\n    super.connectedCallback();\n    this.__outlineNode = this.$.outline;\n    this._observer = new MutationObserver(this._observer.bind(this));\n    this._observer.observe(this.__outlineNode, {\n      childList: true,\n      subtree: true\n    });\n  }\n  /**\n   * Mutation observer callback\n   * @todo current issue if you copy and paste into the same node\n   */\n  _observer(record) {\n    let reference;\n    for (var index in record) {\n      let info = record[index];\n      if (info.removedNodes.length > 0 && this.__outdent) {\n        for (let i in info.removedNodes) {\n          if (\n            reference &&\n            info.removedNodes[i].tagName &&\n            info.removedNodes[i].tagName === \"LI\" &&\n            info.removedNodes[i].getAttribute(\"data-jos-id\") !== null\n          ) {\n            reference.setAttribute(\n              \"data-jos-id\",\n              info.removedNodes[i].getAttribute(\"data-jos-id\")\n            );\n            if (\n              info.removedNodes[i].getAttribute(\"data-jos-location\") !== null\n            ) {\n              reference.setAttribute(\n                \"data-jos-location\",\n                info.removedNodes[i].getAttribute(\"data-jos-location\")\n              );\n            }\n            reference = null;\n          } else if (\n            info.removedNodes[i].tagName === \"UL\" &&\n            info.removedNodes[i].firstChild &&\n            info.removedNodes[i].firstChild.tagName === \"LI\" &&\n            info.removedNodes[i].firstChild.getAttribute(\"data-jos-id\") !== null\n          ) {\n            reference.setAttribute(\n              \"data-jos-id\",\n              info.removedNodes[i].firstChild.getAttribute(\"data-jos-id\")\n            );\n            if (\n              info.removedNodes[i].firstChild.getAttribute(\n                \"data-jos-location\"\n              ) !== null\n            ) {\n              reference.setAttribute(\n                \"data-jos-location\",\n                info.removedNodes[i].firstChild.getAttribute(\n                  \"data-jos-location\"\n                )\n              );\n            }\n            reference = null;\n          }\n        }\n        // ensure there's always a first child node present\n        // this way people can't break the interact via mass deleting\n        if (!this.$.outline.firstChild) {\n          this.$.outline.appendChild(document.createElement(\"li\"));\n        }\n      }\n      // if we've got new nodes to react to that were not imported\n      if (info.addedNodes.length > 0) {\n        // special rules for an outdent event\n        if (this.__outdent) {\n          for (let i in info.addedNodes) {\n            if (\n              info.addedNodes[i].tagName &&\n              info.addedNodes[i].tagName === \"LI\"\n            ) {\n              reference = info.addedNodes[i];\n            }\n          }\n        } else if (!this.__blockScrub) {\n          for (let i in info.addedNodes) {\n            if (info.addedNodes[i].tagName) {\n              // @todo need to ensure that this isn't the same exact item in the same exact position\n              window.JSONOutlineSchema.requestAvailability().scrubElementJOSData(\n                info.addedNodes[i]\n              );\n            }\n          }\n        }\n      }\n    }\n    setTimeout(() => {\n      this.__blockScrub = false;\n      this.__outdent = false;\n      this.__indent = false;\n    }, 100);\n  }\n  /**\n   * Disconnected life cycle\n   */\n  disconnectedCallback() {\n    super.disconnectedCallback();\n  }\n\n  // Observer editMode for changes\n  _editModeChanged(newValue, oldValue) {\n    if (typeof newValue !== typeof undefined) {\n    }\n  }\n  /**\n   * Button events internally\n   */\n  buttonEvents(e) {\n    switch (e.target.id) {\n      case \"add\":\n        this._add(e);\n        break;\n      case \"indent\":\n        this._indent();\n        break;\n      case \"outdent\":\n        this._outdent();\n        break;\n      case \"up\":\n        this._move(\"up\");\n        break;\n      case \"down\":\n        this._move(\"down\");\n        break;\n      case \"duplicate\":\n        this._duplicate();\n        break;\n    }\n  }\n  /**\n   * Duplicate whatever has selection\n   */\n  _duplicate() {\n    // get active item from where cursor is\n    try {\n      let range = this.getDeepRange();\n      if (typeof range.commonAncestorContainer === typeof undefined) {\n        return;\n      }\n      let activeItem = range.commonAncestorContainer;\n      if (\n        activeItem === null ||\n        typeof activeItem === typeof undefined ||\n        typeof activeItem.tagName === typeof undefined\n      ) {\n        activeItem = activeItem.parentNode;\n      }\n      if (activeItem) {\n        // clone the item's hierarchy as well\n        if (\n          activeItem.nextElementSibling !== null &&\n          activeItem.nextElementSibling.tagName === \"UL\"\n        ) {\n          // copy the UL and all children and insert it after the UL it's duplicating\n          const clone2 = activeItem.nextElementSibling.cloneNode(true);\n          activeItem.parentNode.insertBefore(\n            clone2,\n            activeItem.nextElementSibling.nextElementSibling\n          );\n          // clone the LI, placing it before the UL we just made\n          const clone = activeItem.cloneNode(true);\n          activeItem.parentNode.insertBefore(\n            clone,\n            activeItem.nextElementSibling.nextElementSibling\n          );\n        } else {\n          const clone = activeItem.cloneNode(true);\n          // insert the clone AFTER the current selection\n          activeItem.parentNode.insertBefore(\n            clone,\n            activeItem.nextElementSibling\n          );\n        }\n      }\n    } catch (e) {\n      console.log(e);\n    }\n  }\n  /**\n   * Move whatever has selection up or down\n   */\n  _move(direction) {\n    // get active item from where cursor is\n    try {\n      let range = this.getDeepRange();\n      if (typeof range.commonAncestorContainer === typeof undefined) {\n        return;\n      }\n      let activeItem = range.commonAncestorContainer;\n      if (\n        activeItem === null ||\n        typeof activeItem === typeof undefined ||\n        typeof activeItem.tagName === typeof undefined\n      ) {\n        activeItem = activeItem.parentNode;\n      }\n      let test = activeItem;\n      let valid = false;\n      // ensure this operation is executed in scope\n      while (!valid && test.parentNode) {\n        if (test.id === \"outline\") {\n          valid = true;\n        }\n        test = test.parentNode;\n      }\n      // ensure from all that, we have something\n      if (valid && activeItem) {\n        // move the things above us, below us\n        if (direction === \"up\") {\n          // ensure there's something above us\n          if (activeItem.previousElementSibling !== null) {\n            // see if we are moving us, or us and the hierarchy\n            if (\n              activeItem.nextElementSibling &&\n              activeItem.nextElementSibling.tagName === \"UL\"\n            ) {\n              // see if the thing we have to move above has it's own structure\n              if (activeItem.previousElementSibling.tagName === \"UL\") {\n                // ensure we don't lose our metadata\n                this.__blockScrub = true;\n                // insert the element currently above us, just before 2 places back; so behind our UL\n                activeItem.parentNode.insertBefore(\n                  activeItem.previousElementSibling,\n                  activeItem.nextElementSibling.nextElementSibling\n                );\n              }\n              this.__blockScrub = true;\n              // now insert the LI above us, 2 places back so it is in front of the UL\n              activeItem.parentNode.insertBefore(\n                activeItem.previousElementSibling,\n                activeItem.nextElementSibling.nextElementSibling\n              );\n              activeItem.focus();\n            } else {\n              // easier use case, we are moving ourselves only but above us is a UL\n              if (activeItem.previousElementSibling.tagName === \"UL\") {\n                this.__blockScrub = true;\n                // move the UL after us\n                activeItem.parentNode.insertBefore(\n                  activeItem.previousElementSibling,\n                  activeItem.nextElementSibling\n                );\n              }\n              this.__blockScrub = true;\n              // now move the LI after us\n              activeItem.parentNode.insertBefore(\n                activeItem.previousElementSibling,\n                activeItem.nextElementSibling\n              );\n              activeItem.focus();\n            }\n          }\n        } else if (direction === \"down\") {\n          // if nothing after us, we can't move\n          if (activeItem.nextElementSibling !== null) {\n            // account for having to hop over children\n            if (\n              activeItem.nextElementSibling &&\n              activeItem.nextElementSibling.tagName === \"UL\" &&\n              activeItem.nextElementSibling.nextElementSibling !== null\n            ) {\n              // an outline is just below us\n              if (\n                activeItem.nextElementSibling.nextElementSibling.tagName ===\n                  \"LI\" &&\n                activeItem.nextElementSibling.nextElementSibling\n                  .nextElementSibling !== null &&\n                activeItem.nextElementSibling.nextElementSibling\n                  .nextElementSibling.tagName === \"UL\"\n              ) {\n                this.__blockScrub = true;\n                // move the thing 2 down to just before us; so the UL\n                activeItem.parentNode.insertBefore(\n                  activeItem.nextElementSibling.nextElementSibling,\n                  activeItem\n                );\n              }\n              this.__blockScrub = true;\n              // now move the LI that is 2 below us just above us\n              activeItem.parentNode.insertBefore(\n                activeItem.nextElementSibling.nextElementSibling,\n                activeItem\n              );\n              activeItem.focus();\n            } else if (activeItem.nextElementSibling.tagName === \"LI\") {\n              // just moving 1 tag, see if we need to move 2 things about us or 1\n              if (\n                activeItem.nextElementSibling.nextElementSibling !== null &&\n                activeItem.nextElementSibling.nextElementSibling.tagName ===\n                  \"UL\"\n              ) {\n                this.__blockScrub = true;\n                activeItem.parentNode.insertBefore(\n                  activeItem.nextElementSibling,\n                  activeItem\n                );\n              }\n              this.__blockScrub = true;\n              // work on the LI\n              activeItem.parentNode.insertBefore(\n                activeItem.nextElementSibling,\n                activeItem\n              );\n              activeItem.focus();\n            }\n          }\n        }\n      }\n    } catch (e) {\n      console.log(e);\n    }\n  }\n  /**\n   * Take the current manifest and import it into an HTML outline\n   */\n  importJsonOutlineSchemaItems() {\n    this.__blockScrub = true;\n    // wipe out the outline\n    while (this.$.outline.firstChild !== null) {\n      this.$.outline.removeChild(this.$.outline.firstChild);\n    }\n    if (this.items.length === 0) {\n      // get from JOS items if we have none currently\n      this.set(\"items\", window.JSONOutlineSchema.requestAvailability().items);\n    }\n    let outline = window.JSONOutlineSchema.requestAvailability().itemsToNodes(\n      this.items\n    );\n    // rebuild the outline w/ children we just found\n    while (outline.firstChild !== null) {\n      this.__blockScrub = true;\n      this.$.outline.appendChild(outline.firstChild);\n    }\n    return outline;\n  }\n  /**\n   * Take what's currently in the area and get JSON Outline Schema; optionally save\n   */\n  exportJsonOutlineSchemaItems(save = false) {\n    return window.JSONOutlineSchema.requestAvailability().nodesToItems(\n      this.$.outline,\n      save\n    );\n  }\n  /**\n   * Find the next thing to tab forward to.\n   */\n  _tabKeyPressed(e) {\n    e.preventDefault();\n    e.stopPropagation();\n    e.stopImmediatePropagation();\n    if (e.detail.keyboardEvent) {\n      e.detail.keyboardEvent.preventDefault();\n      e.detail.keyboardEvent.stopPropagation();\n      e.detail.keyboardEvent.stopImmediatePropagation();\n    }\n    try {\n      this._indent();\n    } catch (e) {}\n  }\n  _indent() {\n    if (this.polyfillSafe) {\n      this.__indent = true;\n      this.__blockScrub = true;\n      document.execCommand(\"indent\");\n    }\n  }\n  _add(e) {\n    e.preventDefault();\n    e.stopPropagation();\n    e.stopImmediatePropagation();\n    if (this.polyfillSafe) {\n      document.execCommand(\"insertText\", false, \"\\n\");\n    }\n  }\n  /**\n   * Move back through things when tab back pressed\n   */\n  _tabBackKeyPressed(e) {\n    e.preventDefault();\n    e.stopPropagation();\n    e.stopImmediatePropagation();\n    if (e.detail.keyboardEvent) {\n      e.detail.keyboardEvent.preventDefault();\n      e.detail.keyboardEvent.stopPropagation();\n      e.detail.keyboardEvent.stopImmediatePropagation();\n    }\n    // try selection / tab block since range can cause issues\n    try {\n      this._outdent();\n    } catch (e) {}\n  }\n  _outdent() {\n    if (this.polyfillSafe) {\n      this.__outdent = true;\n      this.__blockScrub = true;\n      document.execCommand(\"outdent\");\n    }\n  }\n  /**\n   * Selection normalizer\n   */\n  getDeepSelection() {\n    // try and obtain the selection from the nearest shadow\n    // which would give us the selection object when running native ShadowDOM\n    // with fallback support for the entire window which would imply Shady\n    // native API\n    if (this.shadowRoot.getSelection) {\n      return this.shadowRoot.getSelection();\n    }\n    // ponyfill from google\n    else if (getRange(this.$.outline.parentNode)) {\n      return getRange(this.$.outline.parentNode);\n    }\n    // missed on both, hope the normal one will work\n    return window.getSelection();\n  }\n  /**\n   * Get a normalized range based on current selection\n   */\n  getDeepRange() {\n    let sel = this.getDeepSelection();\n    if (sel.getRangeAt && sel.rangeCount) {\n      return sel.getRangeAt(0);\n    } else if (sel) {\n      return sel;\n    } else false;\n  }\n  /**\n   * These are our bad actors in polyfill'ed browsers.\n   * This means that https://github.com/webcomponents/webcomponentsjs/commit/ce464bb533bf39b544c312906499a6044ee0d30d\n   * explains things but basically if shadow-dom is polyfilled\n   * then we can't safely execute a DOM manipulating execCommand.\n   * This\n   */\n  __computePolyfillSafe() {\n    if (document.head.createShadowRoot || document.head.attachShadow) {\n      return true;\n    } else {\n      console.log(\"Shadow DOM missing, certain operations hidden\");\n      return false;\n    }\n  }\n}\nwindow.customElements.define(EditableOutline.tag, EditableOutline);\nexport { EditableOutline };\n"],"names":["validNodeTypes","Node","ELEMENT_NODE","TEXT_NODE","DOCUMENT_FRAGMENT_NODE","findNode","s","parentNode","isLeft","node","nodes","childNodes","children","i","length","childNode","includes","nodeType","containsNode","addInternalListener","document","createElement","attachShadow","mode","getSelection","addEventListener","ev","dispatchEvent","CustomEvent","withinInternals","handlers","window","setTimeout","forEach","fn","push","wasCaret","resolveTask","containsNextElement","walkForward","start","walkFromNode","contains","Element","previousSibling","nextSibling","initialSpace","exec","textContent","type","Promise","resolve","then","cachedRange","Map","getRange","root","rangeCount","getRangeAt","thisFrame","get","initialText","toString","result","range","createRange","host","insertBefore","fakeSelectionNode","includesBeforeRoot","remove","appendChild","includesAfterRoot","measure","TypeError","rightNode","leftNode","isNaturalDirection","undefined","updatedSize","initialSize","extend","collapseToEnd","modify","getSelectionDirection","at","setStart","setEnd","offsetLeft","offsetRight","size","validRightLength","trailingSpaceCount","ignoredTrailingSpace","internalGetShadowSelection","rs","replace","console","warn","set","createTextNode","EditableOutline","polyfillSafe","_this","__computePolyfillSafe","JSONOutlineSchema","requestAvailability","PolymerElement","html","props","Array","Boolean","Object","assign","__outlineNode","this","$","outline","_observer","MutationObserver","bind","observe","childList","subtree","record","reference","index","info","removedNodes","__outdent","tagName","getAttribute","setAttribute","firstChild","addedNodes","__blockScrub","scrubElementJOSData","_this2","__indent","newValue","oldValue","_typeof","e","target","id","_add","_indent","_outdent","_move","_duplicate","getDeepRange","commonAncestorContainer","activeItem","nextElementSibling","clone2","cloneNode","clone","log","direction","test","valid","previousElementSibling","focus","removeChild","items","itemsToNodes","save","nodesToItems","preventDefault","stopPropagation","stopImmediatePropagation","detail","keyboardEvent","execCommand","shadowRoot","sel","getDeepSelection","head","createShadowRoot","customElements","define","tag"],"mappings":"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"}