{"version":3,"file":"absolute-position-behavior.umd.js","sources":["lib/absolute-position-state-manager.js","absolute-position-behavior.umd.js"],"sourcesContent":["/**\n * Copyright 2018 The Pennsylvania State University\n * @license Apache-2.0, see License.md for full text.\n */\nimport { LitElement } from \"lit-element/lit-element.js\";\nimport \"@polymer/iron-resizable-behavior/iron-resizable-behavior.js\";\n\n// register globally so we can make sure there is only one\nwindow.AbsolutePositionStateManager = window.AbsolutePositionStateManager || {};\n// request if this exists. This helps invoke element existing in dom\n// as well as that there is only one of them. That way we can ensure everything\n// is rendered through same modal\nwindow.AbsolutePositionStateManager.requestAvailability = () => {\n  if (!window.AbsolutePositionStateManager.instance) {\n    window.AbsolutePositionStateManager.instance = document.createElement(\n      \"absolute-position-state-manager\"\n    );\n    let instance = window.AbsolutePositionStateManager.instance;\n    document.body.appendChild(instance);\n  }\n  return window.AbsolutePositionStateManager.instance;\n};\n/**\n * `absolute-position-state-manager`\n * manages state of multiple absolute-positioned elements on a page\n *\n * @customElement\n * @polymer\n */\nclass AbsolutePositionStateManager extends LitElement {\n  /* REQUIRED FOR TOOLING DO NOT TOUCH */\n\n  /**\n   * Store tag name to make it easier to obtain directly.\n   */\n  static get tag() {\n    return \"absolute-position-state-manager\";\n  }\n\n  // properties available to custom element for data binding\n  static get properties() {\n    return {\n      /**\n       * Stores an array of all elements using manager.\n       */\n      elements: {\n        type: Array\n      },\n      /**\n       * mutation observer\n       */\n      __observer: {\n        type: Object\n      },\n      /**\n       * resize timeout\n       */\n      __timeout: {\n        type: Object\n      }\n    };\n  }\n\n  /**\n   * Makes sure there is a utility ready and listening for elements.\n   */\n  constructor() {\n    super();\n    this.elements = [];\n    this.__timeout = false;\n    this.__observer = new MutationObserver(mutations =>\n      this.checkMutations(mutations)\n    );\n  }\n\n  /**\n   * Loads element into array\n   * @param {object} element to be added\n   */\n  loadElement(el) {\n    //only have event listeners when there are elements using manager\n    if (this.elements.length < 1) {\n      this.__observer.observe(document, {\n        attributes: true,\n        childList: true,\n        subtree: true,\n        characterData: true\n      });\n      this.updateElements();\n      document.addEventListener(\"load\", this.updateElements);\n      window.addEventListener(\"resize\", this._handleResize);\n    }\n    this.elements.push(el);\n    this.positionElement(el);\n  }\n\n  /**\n   * Unloads element from array\n   * @param {object} element to be removed\n   */\n  unloadElement(el) {\n    this.elements.filter(element => element === el);\n    if (this.elements.length < 1) this.removeEventListeners();\n  }\n\n  /**\n   * handles resize event\n   */\n  _handleResize() {\n    if (this.__timeout) clearTimeout(this.__timeout);\n    this.__timeout = setTimeout(\n      window.AbsolutePositionStateManager.instance.updateElements(),\n      250\n    );\n  }\n\n  /**\n   * Checks if there are any chances other than to\n   * element's position and updates accordioning.\n   * This is needed so that positioning elements\n   * doesn't trigger an infinite loop of updates.\n   *\n   * @param {array} mutation records\n   * @return {void}\n   */\n  checkMutations(mutations) {\n    let update = false;\n\n    mutations.forEach(mutation => {\n      if (update) return;\n      update =\n        update ||\n        !(\n          mutation.type === \"attributes\" &&\n          mutation.attributeName === \"style\" &&\n          this.elements.includes(mutation.target)\n        );\n    });\n    if (update) this.updateElements();\n  }\n\n  /**\n   * Returns target element that this element is anchored to. It is\n   * either element given by `for` attribute, or immediate parent\n   * of element.\n   *\n   * Uses `target` object if specified.\n   * If not, queries document for elements with id specified in `for` attribute.\n   * If there is more than one element that matches, gets closest matching element.\n   *\n   * @param {object} element using absolute-position behavior\n   * @return {object} target element for positioning\n   */\n  findTarget(el) {\n    let selector = \"#\" + el.for,\n      docQuery =\n        document.querySelectorAll(selector).length === 1\n          ? document.querySelector(selector)\n          : null,\n      target = el.target || docQuery,\n      ancestor = el;\n\n    while (\n      el.for !== undefined &&\n      target === null &&\n      ancestor !== null &&\n      ancestor !== document\n    ) {\n      ancestor = ancestor.parentNode;\n      if (ancestor.nodeType === 11) ancestor = ancestor.host;\n      target = ancestor ? ancestor.querySelector(selector) : null;\n    }\n    return target;\n  }\n\n  /**\n   * Removes event listeners\n   * @return {void}\n   */\n  removeEventListeners() {\n    if (this.__observer && this.__observer.disconnect)\n      this.__observer.disconnect();\n    document.removeEventListener(\"load\", this.updateElements);\n    window.removeEventListener(\"resize\", this._handleResize);\n  }\n\n  /**\n   * Updates position for all elements on page.\n   * @return {void}\n   */\n  updateElements() {\n    this.elements.forEach(element => this.positionElement(element));\n  }\n\n  /**\n   * Gets an updated position based on target.\n   * @param {object} element using absolute-position behavior\n   * @return {void}\n   */\n  positionElement(el) {\n    let target = this.findTarget(el);\n    if (!target || !el.offsetParent) return;\n    let offset = el.offset,\n      parentRect = el.offsetParent.getBoundingClientRect(),\n      targetRect = target.getBoundingClientRect(),\n      elRect = el.getBoundingClientRect(),\n      vertical = position => {\n        //place element before vertically?\n        return position !== \"left\" && position !== \"right\";\n      },\n      before = position => {\n        //place element before target?\n        return position === \"left\" || position === \"top\";\n      },\n      /**\n       * ;\n       *\n       */\n      fitToBounds = () => {\n        //fits element within parent's boundaries\n        let pos1 = vertical(el.position) ? \"left\" : \"top\",\n          pos2 = vertical(el.position) ? \"right\" : \"bottom\",\n          getRect = rect => {\n            return vertical(el.position) ? rect.width : rect.height;\n          },\n          coord =\n            targetRect[pos1] - getRect(elRect) / 2 + getRect(targetRect) / 2,\n          min = parentRect[pos1],\n          max = parentRect[pos2] - getRect(elRect);\n        return el.fitToVisibleBounds\n          ? Math.max(min, Math.min(max, coord)) + \"px\"\n          : coord + \"px\"; //if element size > parent, align where parent begins\n      },\n      getCoord = () => {\n        //adds or subtracts offset from target based on position\n        return el.position === \"top\"\n          ? targetRect.top - elRect.height - offset + \"px\"\n          : el.position === \"left\"\n          ? targetRect.left - elRect.width - offset + \"px\"\n          : targetRect[el.position] + offset + \"px\";\n      },\n      isFit = position => {\n        //determines if room for element between parent and target\n        let size = vertical(position)\n          ? elRect.height + offset\n          : elRect.width + offset;\n        return before(position)\n          ? targetRect[position] - parentRect[position] > size\n          : parentRect[position] - targetRect[position] > size; //if no room, return original position\n      };\n    let flip = el.fitToVisibleBounds !== false && !isFit(el.position),\n      flipData = {\n        top: [\"bottom\", \"left\", \"right\"],\n        left: [\"right\", \"top\", \"bottom\"],\n        bottom: [\"top\", \"right\", \"left\"],\n        right: [\"left\", \"bottom\", \"top\"]\n      };\n    /*\n     * fits element according to specified postion,\n     * or finds an alternative position that fits\n     */\n    if (flip && isFit(flipData[el.position][0])) {\n      el.position = flipData[el.position][0];\n    } else if (flip && isFit(flipData[el.position][1])) {\n      el.position = flipData[el.position][1];\n    } else if (flip && isFit(flipData[el.position][2])) {\n      el.position = flipData[el.position][2];\n    } else {\n      el.style.position = \"absolute\";\n      el.style.top = vertical(el.position) ? getCoord() : fitToBounds();\n      el.style.left = vertical(el.position) ? fitToBounds() : getCoord();\n      //provide positions for element and target (in case furthor positioning adjustments are needed)\n      el.__positions = {\n        self: elRect,\n        parent: parentRect,\n        target: targetRect\n      };\n    }\n  }\n\n  /**\n   * life cycle, element is removed from DOM\n   */\n  disconnectedCallback() {\n    this.removeEventListeners();\n    super.disconnectedCallback();\n  }\n}\nwindow.customElements.define(\n  AbsolutePositionStateManager.tag,\n  AbsolutePositionStateManager\n);\nexport { AbsolutePositionStateManager };\n","/**\n * Copyright 2019 The Pennsylvania State University\n * @license Apache-2.0, see License.md for full text.\n */\nimport { LitElement, html, css } from \"lit-element/lit-element.js\";\nimport \"./lib/absolute-position-state-manager\";\n\n/**\n * `absolute-position-behavior`\n * abstracts absolute positioning behavior to be resusable in other elements\n *\n * @microcopy - language worth noting:\n *  -\n *\n * @customElement\n * @demo demo/index.html\n */\nclass AbsolutePositionBehavior extends LitElement {\n  \n  //styles function\n  static get styles() {\n    return  [\n      css`\n:host {\n  display: inline-block;\n}\n\n:host([hidden]) {\n  display: none;\n}\n      `\n    ];\n  }\n  // render function\n  render() {\n    return html`\n\n<slot></slot>`;\n  }\n\n  // properties available to the custom element for data binding\n    static get properties() {\n    return {\n  \n  ...super.properties,\n  \n  /**\n   * Element is positioned from connected to disconnected?\n   * Otherwise setPosition and unsetPosition must be called manually.\n   */\n  \"auto\": {\n    \"type\": Boolean\n  },\n  /**\n   * If true, no parts of the tooltip will ever be shown offscreen.\n   */\n  \"fitToVisibleBounds\": {\n    \"type\": Boolean,\n    \"attribute\": \"fit-to-visible-bounds\"\n  },\n  /**\n   * The id of the element that the tooltip is anchored to. This element\n   * must be a sibling of the tooltip. If this property is not set,\n   * then the tooltip will be centered to the parent node containing it.\n   */\n  \"for\": {\n    \"type\": String,\n    \"reflect\": true\n  },\n  /**\n   * The spacing between the top of the tooltip and the element it is\n   * anchored to.\n   */\n  \"offset\": {\n    \"type\": Number\n  },\n  /**\n   * Positions the tooltip to the top, right, bottom, left of its content.\n   */\n  \"position\": {\n    \"type\": String,\n    \"reflect\": true\n  },\n  /**\n   * The actual target element\n   */\n  \"target\": {\n    \"type\": Object\n  },\n  /**\n   * The element's style\n   */\n  \"__positions\": {\n    \"type\": Object\n  }\n}\n;\n  }\n\n  /**\n   * Store tag name to make it easier to obtain directly.\n   * @notice function name must be here for tooling to operate correctly\n   */\n  static get tag() {\n    return \"absolute-position-behavior\";\n  }\n\n  constructor() {\n    super();\n    this.auto = false;\n    this.fitToVisibleBounds = false;\n    this.for = null;\n    this.offset = 0;\n    this.position = \"bottom\";\n    this.target = null;\n    this.__positions = {};\n    this.__observe = false;\n    this.__manager = window.AbsolutePositionStateManager.requestAvailability();\n  }\n\n  updated(changedProperties) {\n    changedProperties.forEach((oldValue, propName) => {\n      if (propName === \"auto\" && this.auto) this.setPosition();\n      if (propName === \"auto\" && !this.auto) this.unsetPosition();\n      if (propName === \"fitToVisibleBounds\") this.updatePosition();\n      if (propName === \"for\") this.updatePosition();\n      if (propName === \"offset\") this.updatePosition();\n      if (propName === \"position\") this.updatePosition();\n      if (propName === \"target\") this.updatePosition();\n    });\n  }\n\n  /**\n   * Registers element with AbsolutePositionStateManager\n   * @returns {void}\n   */\n  setPosition() {\n    this.__observe = true;\n    this.__manager.loadElement(this);\n  }\n\n  /**\n   * Unregisters element with AbsolutePositionStateManager\n   * @returns {void}\n   */\n  unsetPosition() {\n    this.__observe = false;\n    this.__manager.unloadElement(this);\n  }\n\n  /**\n   * Updates  element's position\n   * @returns {void}\n   */\n  updatePosition() {\n    if (this.__observe === true) {\n      this.__manager.positionElement(this);\n    }\n  }\n  /**\n   * life cycle, element is removed from DOM\n   * @returns {void}\n   */\n  disconnectedCallback() {\n    this.unsetPosition();\n    super.disconnectedCallback();\n  }\n}\nwindow.customElements.define(\n  AbsolutePositionBehavior.tag,\n  AbsolutePositionBehavior\n);\nexport { AbsolutePositionBehavior };\n"],"names":["window","AbsolutePositionStateManager","requestAvailability","instance","document","createElement","body","appendChild","elements","__timeout","__observer","MutationObserver","mutations","_this","checkMutations","LitElement","type","Array","Object","el","this","length","observe","attributes","childList","subtree","characterData","updateElements","addEventListener","_handleResize","push","positionElement","filter","element","removeEventListeners","clearTimeout","setTimeout","update","forEach","mutation","attributeName","_this2","includes","target","selector","for","docQuery","querySelectorAll","querySelector","ancestor","undefined","parentNode","nodeType","host","disconnect","removeEventListener","_this3","findTarget","offsetParent","offset","parentRect","getBoundingClientRect","targetRect","elRect","vertical","position","fitToBounds","pos1","pos2","getRect","rect","width","height","coord","min","max","fitToVisibleBounds","Math","getCoord","top","left","isFit","size","before","flip","flipData","bottom","right","style","__positions","self","parent","customElements","define","tag","AbsolutePositionBehavior","auto","__observe","__manager","html","css","Boolean","String","Number","changedProperties","oldValue","propName","setPosition","unsetPosition","updatePosition","loadElement","unloadElement"],"mappings":"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"}