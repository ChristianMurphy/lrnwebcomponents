{"version":3,"file":"json-outline-schema.umd.js","sources":["lib/json-outline-schema-item.js","json-outline-schema.umd.js"],"sourcesContent":["/**\n * Copyright 2019 The Pennsylvania State University\n * @license Apache-2.0, see License.md for full text.\n */\n/**\n * `json-outline-schema-item`\n * `A single item inside of json outline schema's items array`\n *\n * @microcopy - language worth noting:\n *  - outline-schema - a schema for expressing the relationship between structured content items\n *  - item - one item within an outline with reference to a resource to load the contents of the item\n */\nclass JSONOutlineSchemaItem {\n  /**\n   * Establish defaults for a new item\n   */\n  constructor() {\n    this.id = \"item-\" + this.generateUUID();\n    this.title = \"New item\";\n    this.location = \"\";\n    this.description = \"\";\n    this.parent = \"\";\n    this.metadata = {};\n    this.order = 0;\n    this.indent = 0;\n  }\n  /**\n   * Load data from the location specified\n   */\n  readLocation(basePath = \"\") {\n    // @todo read location and return contents of it\n    //    if (file_exists(basePath + this.location)) {\n    //      return file_get_contents(basePath + this.location);\n    //    }\n    return FALSE;\n  }\n  /**\n   * Load data from the location specified\n   */\n  writeLocation(body, basePath = \"\") {\n    //    if (file_exists(basePath + this.location)) {\n    //      return file_put_contents(basePath + this.location, body);\n    //    }\n    return FALSE;\n  }\n  /**\n   * Generate a UUID\n   */\n  generateUUID() {\n    return \"ss-s-s-s-sss\".replace(/s/g, this._uuidPart);\n  }\n  _uuidPart() {\n    return Math.floor((1 + Math.random()) * 0x10000)\n      .toString(16)\n      .substring(1);\n  }\n}\nexport { JSONOutlineSchemaItem };\n","/**\n * Copyright 2019 The Pennsylvania State University\n * @license Apache-2.0, see License.md for full text.\n */\nimport { JSONOutlineSchemaItem } from \"./lib/json-outline-schema-item.js\";\n// register globally so we can make sure there is only one\nwindow.JSONOutlineSchema = window.JSONOutlineSchema || {};\n// request if this exists. This helps invoke the element existing in the dom\n// as well as that there is only one of them. That way we can ensure everything\n// is rendered through the same json-outline-schema element, making it a singleton.\nwindow.JSONOutlineSchema.requestAvailability = () => {\n  // if there is no single instance, generate one and append it to end of the document\n  if (!window.JSONOutlineSchema.instance) {\n    window.JSONOutlineSchema.instance = document.createElement(\n      \"json-outline-schema\"\n    );\n    document.body.appendChild(window.JSONOutlineSchema.instance);\n  }\n  return window.JSONOutlineSchema.instance;\n};\n/**\n * `json-outline-schema`\n * `JS based state management helper for the json outline schema spec`\n *\n * @microcopy - language worth noting:\n *  -\n *\n * @customElement\n * @demo demo/index.html\n */\n\nclass JsonOutlineSchema extends HTMLElement {\n  \n  // render function\n  get html() {\n    return `\n<style>:host {\n  display: block;\n}\n:host([debug]) {\n  font-family: monospace;\n  white-space: pre;\n  margin: 16px 0px;\n}\n:host([hidden]) {\n  display: none;\n}\n</style>\n<slot></slot>`;\n  }\n\n  // properties available to the custom element for data binding\n    static get properties() {\n    let props = {}\n;\n    if (super.properties) {\n      props = Object.assign(props, super.properties);\n    }\n    return props;\n  }\n\n  /**\n   * Store the tag name to make it easier to obtain directly.\n   * @notice function name must be here for tooling to operate correctly\n   */\n  static get tag() {\n    return \"json-outline-schema\";\n  }\n  /**\n   * life cycle\n   */\n  constructor(delayRender = false) {\n    super();\n    // set tag for later use\n    this.tag = JsonOutlineSchema.tag;\n    this.template = document.createElement(\"template\");\n\n    this.attachShadow({ mode: \"open\" });\n\n    if (!delayRender) {\n      this.render();\n    }\n    this.__ready = false;\n    this.file = null;\n    this.id = this.generateUUID();\n    this.title = \"New site\";\n    this.author = \"\";\n    this.description = \"\";\n    this.license = \"by-sa\";\n    this.metadata = {};\n    this.items = [];\n    this.debug = false;\n    window.JSONOutlineSchema.instance = this;\n  }\n  /**\n   * life cycle, element is afixed to the DOM\n   */\n  connectedCallback() {\n    if (window.ShadyCSS) {\n      window.ShadyCSS.styleElement(this);\n    }\n\n    window.addEventListener(\n      \"json-outline-schema-debug-toggle\",\n      this._toggleDebug.bind(this)\n    );\n\n    const evt = new CustomEvent(\"json-outline-schema-ready\", {\n      bubbles: true,\n      cancelable: false,\n      composed: true,\n      detail: true\n    });\n    this.dispatchEvent(evt);\n    this.__ready = true;\n  }\n\n  _copyAttribute(name, to) {\n    const recipients = this.shadowRoot.querySelectorAll(to);\n    const value = this.getAttribute(name);\n    const fname = value == null ? \"removeAttribute\" : \"setAttribute\";\n    for (const node of recipients) {\n      node[fname](name, value);\n    }\n  }\n\n  _setProperty({ name, value }) {\n    this[name] = value;\n  }\n\n  render() {\n    this.shadowRoot.innerHTML = null;\n    this.template.innerHTML = this.html;\n\n    if (window.ShadyCSS) {\n      window.ShadyCSS.prepareTemplate(this.template, this.tag);\n    }\n    this.shadowRoot.appendChild(this.template.content.cloneNode(true));\n  }\n  /**\n   * life cycle, element is removed from the DOM\n   */\n  disconnectedCallback() {\n    window.removeEventListener(\n      \"json-outline-schema-debug-toggle\",\n      this._toggleDebug.bind(this)\n    );\n    const evt = new CustomEvent(\"json-outline-schema-unready\", {\n      bubbles: true,\n      cancelable: false,\n      detail: true\n    });\n    this.dispatchEvent(evt);\n  }\n  /**\n   * Get a clone of this JSONOutlineSchema object\n   * @return Object\n   */\n  clone() {\n    const schema = {\n      id: this.id,\n      title: this.title,\n      author: this.author,\n      description: this.description,\n      license: this.license,\n      metadata: this.metadata,\n      items: this.items\n    };\n    const obj = JSON.parse(JSON.stringify(schema));\n    return obj;\n  }\n  /**\n   * Get a new item matching schema standards\n   * @return new JSONOutlineSchemaItem Object\n   */\n  newItem() {\n    return new JSONOutlineSchemaItem();\n  }\n  /**\n   * Add an item to the outline\n   * @var item an array of values, keyed to match JSON Outline Schema\n   * @return count of items in the array\n   */\n  addItem(item) {\n    let safeItem = this.validateItem(item);\n    count = array_push(this.items, safeItem);\n    return count;\n  }\n  /**\n   * Validate that an item matches JSONOutlineSchemaItem format\n   * @var item JSONOutlineSchemaItem\n   * @return JSONOutlineSchemaItem matching the specification\n   */\n  validateItem(item) {\n    // create a generic schema item\n    let tmp = new JSONOutlineSchemaItem();\n    for (var key in tmp) {\n      // only set what the element from spec allows into a new object\n      if (typeof item[key] !== typeof undefined) {\n        tmp[key] = item[key];\n      }\n    }\n    return tmp;\n  }\n  /**\n   * Remove an item from the outline if it exists\n   * @var id an id that's in the array of items\n   * @return JSONOutlineSchemaItem or false if not found\n   */\n  removeItem(id) {\n    for (var key in this.items) {\n      if (this.items[key].id == id) {\n        let tmp = this.items[key];\n        delete this.items[key];\n        return tmp;\n      }\n    }\n    return false;\n  }\n  /**\n   * Remove an item from the outline if it exists\n   * @var id an id that's in the array of items\n   * @return JSONOutlineSchemaItem or false if not found\n   */\n  updateItem(item, save = false) {\n    // verify this is a legit item\n    let safeItem = this.validateItem(item);\n    for (var key in this.items) {\n      // match the current item's ID to our safeItem passed in\n      if (this.items[key].id == safeItem.id) {\n        // overwrite the item\n        this.items[key] = safeItem;\n        // if we save, then we let that return the whole file\n        if (save) {\n          return this.save();\n        }\n        // this was successful\n        return true;\n      }\n    }\n    // we didn't find a match on the ID to bother saving an update\n    return false;\n  }\n  /**\n   * Load a schema from a file\n   */\n  async load(location) {\n    if (location) {\n      this.file = location;\n      let data = await fetch(location).then(function(response) {\n        return response.text();\n      });\n      let fileData = JSON.parse(data);\n      for (var key in fileData) {\n        if (typeof this[key] !== typeof undefined && key !== \"items\") {\n          this[key] = fileData[key];\n        }\n      }\n      // check for items and escalate to full JSONOutlineSchemaItem object\n      // also ensures data matches only what is supported\n      if (fileData.items) {\n        for (var key in fileData.items) {\n          let item = fileData.items[key];\n          let newItem = new JSONOutlineSchemaItem();\n          newItem.id = item.id;\n          newItem.indent = item.indent;\n          newItem.location = item.location;\n          newItem.order = item.order;\n          newItem.parent = item.parent;\n          newItem.title = item.title;\n          newItem.description = item.description;\n          // metadata can be anything so whatever\n          newItem.metadata = item.metadata;\n          this.items[key] = newItem;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Save data back to the file system location\n   */\n  save() {\n    let schema = {\n      id: this.id,\n      title: this.title,\n      author: this.author,\n      description: this.description,\n      license: this.license,\n      metadata: this.metadata,\n      items: this.items\n    };\n    // @todo write contents\n    //return @file_put_contents(this.file, JSON.stringify(schema, null, 2));\n    return JSON.stringify(schema, null, 2);\n  }\n  /**\n   * Generate a UUID\n   */\n  generateUUID() {\n    return \"ss-s-s-s-sss\".replace(/s/g, this._uuidPart);\n  }\n  _uuidPart() {\n    return Math.floor((1 + Math.random()) * 0x10000)\n      .toString(16)\n      .substring(1);\n  }\n  /**\n   * Allow toggling of debug mode which visualizes the outline and writes it to console.\n   */\n  _toggleDebug(e) {\n    this.debug = !this.debug;\n    this._triggerDebugPaint(this.debug);\n  }\n  /**\n   * Paint the slot in order to debug the object inside\n   */\n  _triggerDebugPaint(debug) {\n    if (debug) {\n      let obj = {\n        file: this.file,\n        id: this.id,\n        title: this.title,\n        author: this.author,\n        description: this.description,\n        license: this.license,\n        metadata: this.metadata,\n        items: this.items\n      };\n      let span = document.createElement(\"span\");\n      span.innerHTML = JSON.stringify(obj, null, 2);\n      this.shadowRoot.appendChild(span.cloneNode(true));\n    } else {\n      this.render();\n    }\n  }\n  static get observedAttributes() {\n    return [\"file\", \"id\", \"title\", \"author\", \"description\", \"license\", \"debug\"];\n  }\n\n  attributeChangedCallback(attr, oldValue, newValue) {\n    if (this.debug) {\n      this.render();\n      this._triggerDebugPaint(this.debug);\n    }\n  }\n  get file() {\n    return this.getAttribute(\"file\");\n  }\n  set file(newValue) {\n    if (this.__ready) {\n      this.setAttribute(\"file\", newValue);\n    }\n  }\n  get id() {\n    return this.getAttribute(\"id\");\n  }\n  set id(newValue) {\n    if (this.__ready) {\n      this.setAttribute(\"id\", newValue);\n    }\n  }\n  get title() {\n    return this.getAttribute(\"title\");\n  }\n  set title(newValue) {\n    if (this.__ready) {\n      this.setAttribute(\"title\", newValue);\n    }\n  }\n  get author() {\n    return this.getAttribute(\"author\");\n  }\n  set author(newValue) {\n    if (this.__ready) {\n      this.setAttribute(\"author\", newValue);\n    }\n  }\n  get description() {\n    return this.getAttribute(\"description\");\n  }\n  set description(newValue) {\n    if (this.__ready) {\n      this.setAttribute(\"description\", newValue);\n    }\n  }\n  get license() {\n    return this.getAttribute(\"license\");\n  }\n  set license(newValue) {\n    if (this.__ready) {\n      this.setAttribute(\"license\", newValue);\n    }\n  }\n  get debug() {\n    return this.getAttribute(\"debug\");\n  }\n  set debug(newValue) {\n    if (this.__ready && newValue) {\n      this.setAttribute(\"debug\", newValue);\n    } else {\n      this.removeAttribute(\"debug\");\n    }\n  }\n  /**\n   * Set individual key values pairs on metdata so we can notice it change\n   */\n  updateMetadata(key, value) {\n    this.metadata[key] = value;\n    if (this.debug) {\n      this.render();\n      this._triggerDebugPaint(this.debug);\n    }\n  }\n\n  /**\n   * Return some items populated correctly\n   */\n  getItemValues(item, parent = false) {\n    var valid;\n    if (item) {\n      valid = this.validateItem(item);\n    } else {\n      valid = new JSONOutlineSchemaItem();\n    }\n    // treat this item as the parent\n    if (parent) {\n      valid.parent = parent.id;\n    }\n    return valid;\n  }\n  /**\n   * Return valid JSON Schema relative to what asked for\n   */\n  getItemSchema(requested = \"item\") {\n    var schema = {\n      $schema: \"http://json-schema.org/schema#\",\n      title: this.title,\n      type: \"object\",\n      properties: {}\n    };\n    var obj;\n    if (requested == \"item\") {\n      obj = new JSONOutlineSchemaItem();\n    } else {\n      // current object definition but without the outline\n      obj = {\n        file: this.file,\n        id: this.id,\n        title: this.title,\n        author: this.author,\n        description: this.description,\n        license: this.license,\n        metadata: this.metadata\n      };\n      // support this as fallback\n      if (requested == \"outline\") {\n        obj.items = this.items;\n      }\n    }\n    for (var key in obj) {\n      let props = {\n        title: key,\n        type: \"string\",\n        value: obj[key]\n      };\n      switch (key) {\n        case \"file\":\n        case \"id\":\n        case \"title\":\n        case \"author\":\n        case \"description\":\n        case \"license\":\n        case \"location\":\n        // @todo break parent out into selector\n        case \"parent\":\n          props.component = {\n            name: \"paper-input\",\n            valueProperty: \"value\",\n            properties: {\n              required: true\n            }\n          };\n          break;\n        case \"indent\":\n        case \"order\":\n          props.component = {\n            name: \"paper-input\",\n            valueProperty: \"value\",\n            properties: {\n              required: true\n            },\n            attributes: {\n              type: \"number\"\n            }\n          };\n        case \"metadata\":\n        case \"items\":\n          props.type = \"array\";\n          props.items = {\n            type: \"object\",\n            properties: {\n              key: {\n                title: \"key\",\n                type: \"string\",\n                component: {\n                  name: \"paper-input\",\n                  valueProperty: \"value\",\n                  properties: {\n                    required: true\n                  }\n                }\n              },\n              value: {\n                title: \"value\",\n                type: \"string\",\n                component: {\n                  name: \"paper-input\",\n                  valueProperty: \"value\",\n                  properties: {\n                    required: true\n                  }\n                }\n              }\n            }\n          };\n          break;\n        default:\n          console.log(key);\n          break;\n      }\n      schema.properties[key] = props;\n    }\n    return schema;\n  }\n  /**\n   * Take the items of the manifest (or passed in) and generate an HTML list hierarchy from it\n   */\n  itemsToNodes(items = []) {\n    if (items.length === 0) {\n      items = this.items;\n    }\n    let tree = this.unflattenItems(items);\n    return this.treeToNodes(tree, document.createElement(\"ul\"));\n  }\n  treeToNodes(tree, appendTarget) {\n    for (var i in tree) {\n      let li = document.createElement(\"li\");\n      li.innerText = tree[i].title;\n      li.setAttribute(\"data-jos-id\", tree[i].id);\n      if (tree[i].location) {\n        li.setAttribute(\"data-jos-location\", tree[i].location);\n      }\n      appendTarget.appendChild(li);\n      if (tree[i].children && tree[i].children.length > 0) {\n        appendTarget.appendChild(\n          this.treeToNodes(tree[i].children, document.createElement(\"ul\"))\n        );\n      }\n    }\n    return appendTarget;\n  }\n  /**\n   * Helper to unflatten an array and make it into a tree\n   */\n  unflattenItems(items, parent, tree) {\n    tree = typeof tree !== \"undefined\" ? tree : [];\n    parent = typeof parent !== \"undefined\" ? parent : { id: null };\n    let children = items.filter(child => {\n      return child.parent === parent.id;\n    });\n    if (children.length) {\n      if (!parent.id) {\n        tree = children;\n      } else {\n        parent.children = children;\n      }\n      children.forEach(child => {\n        this.unflattenItems(items, child);\n      });\n    }\n    return tree;\n  }\n  /**\n   * Scrubs data-jos metadata from node and any children of the node.\n   * Useful when dealing with text based data being turned into nodes (like a paste)\n   */\n  scrubElementJOSData(node) {\n    // attempt to replace things inside very aggressively\n    for (var i in node.children) {\n      node.removeAttribute(\"data-jos-id\");\n      node.removeAttribute(\"data-jos-location\");\n      // deep scrub child references\n      if (node.children[i].children) {\n        this.scrubElementJOSData(node.children[i]);\n      }\n    }\n  }\n  /**\n   * Take an HTML node and convert it into a JSON Outline Schema based\n   * on parent child relationshios found in the node. Commonly used with ul / ol\n   */\n  nodesToItems(node, save = false) {\n    const items = this.getChildOutline(node);\n    if (save) {\n      this.items = items;\n      // update if debugging is turned on\n      if (this.debug) {\n        this.render();\n        this._triggerDebugPaint(this.debug);\n      }\n    }\n    return items;\n  }\n  /**\n   * Generate a flat listing of items in JSON OUtline Schema format\n   * from a hierarchy of HTML nodes\n   */\n  getChildOutline(node, order = 0, indent = 0, parent = null) {\n    // deep clone the first node so we don't destroy the original\n    const clone = node.cloneNode(true);\n    let items = [];\n    let item = {};\n    while (clone.firstChild !== null) {\n      // only work on things if they are valid HTML nodes\n      if (typeof clone.firstChild.tagName !== typeof undefined) {\n        const child = clone.firstChild;\n        // walk deeper as this element has a child element\n        if (\n          child.firstChild !== null &&\n          typeof child.firstChild.tagName !== typeof undefined\n        ) {\n          // usually this will happen but it's possible to have a corrupted\n          // structure in HTML where there are lots of ULs with no immediate children\n          // in this case we defer to whoever the parent of this item was\n          // This means on a recall that the visual issue would be corrected\n          // but it also means the data will technically transform the HTML structure\n          // which for our purposes, is a good thing.\n          let parentPassdown = parent;\n          // ensure this is set\n          if (typeof item.id !== typeof undefined) {\n            parentPassdown = item.id;\n          }\n          // recursive; dive in using the current child as the starting point\n          // and merge in everything we dig up from there\n          items = items.concat(\n            this.getChildOutline(child, 0, indent + 1, parentPassdown)\n          );\n        } else {\n          item = new JSONOutlineSchemaItem();\n          // allow for DOM to have defined an id ahead of time\n          if (child.getAttribute(\"data-jos-id\")) {\n            item.id = child.getAttribute(\"data-jos-id\");\n          }\n          if (child.getAttribute(\"data-jos-location\")) {\n            item.location = child.getAttribute(\"data-jos-location\");\n          } else {\n            item.location = \"\";\n          }\n          item.indent = indent;\n          item.order = order;\n          order = order + 1;\n          // @todo mayyyyyy work but if nested structures may not for text\n          // @todo need to look for a textNode that has the element content\n          item.title = child.innerText;\n          item.parent = parent;\n          items.push(item);\n        }\n      }\n      clone.removeChild(clone.firstChild);\n    }\n    return items;\n  }\n  /**\n   * Get Next Page\n   */\n  nextPage(manifest, activeItem) {\n    manifest.items = manifest.items\n      // top level\n      .sort((a, b) => {});\n  }\n}\nwindow.customElements.define(JsonOutlineSchema.tag, JsonOutlineSchema);\nexport { JsonOutlineSchema, JSONOutlineSchemaItem };\n"],"names":["JSONOutlineSchemaItem","id","this","generateUUID","title","location","description","parent","metadata","order","indent","FALSE","body","replace","_uuidPart","Math","floor","random","toString","substring","window","JSONOutlineSchema","requestAvailability","instance","document","createElement","appendChild","JsonOutlineSchema","delayRender","tag","template","attachShadow","mode","render","__ready","file","_this","author","license","items","debug","HTMLElement","props","Object","assign","ShadyCSS","styleElement","addEventListener","_toggleDebug","bind","evt","CustomEvent","bubbles","cancelable","composed","detail","dispatchEvent","name","to","recipients","shadowRoot","querySelectorAll","value","getAttribute","fname","innerHTML","html","prepareTemplate","content","cloneNode","removeEventListener","schema","JSON","parse","stringify","item","safeItem","validateItem","count","array_push","tmp","key","_typeof","save","fetch","then","response","text","data","fileData","newItem","e","_triggerDebugPaint","obj","span","attr","oldValue","newValue","valid","requested","$schema","type","properties","component","valueProperty","required","attributes","console","log","length","tree","unflattenItems","treeToNodes","appendTarget","i","li","innerText","setAttribute","children","filter","child","forEach","_this2","node","removeAttribute","scrubElementJOSData","getChildOutline","clone","firstChild","tagName","parentPassdown","concat","push","removeChild","manifest","activeItem","sort","a","b","customElements","define"],"mappings":"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"}